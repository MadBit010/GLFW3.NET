// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace glfw3
{
    public enum VkResult
    {
        VK_SUCCESS = 0,
        VK_NOT_READY = 1,
        VK_TIMEOUT = 2,
        VK_EVENT_SET = 3,
        VK_EVENT_RESET = 4,
        VK_INCOMPLETE = 5,
        VK_ERROR_OUT_OF_HOST_MEMORY = -1,
        VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
        VK_ERROR_INITIALIZATION_FAILED = -3,
        VK_ERROR_DEVICE_LOST = -4,
        VK_ERROR_MEMORY_MAP_FAILED = -5,
        VK_ERROR_LAYER_NOT_PRESENT = -6,
        VK_ERROR_EXTENSION_NOT_PRESENT = -7,
        VK_ERROR_FEATURE_NOT_PRESENT = -8,
        VK_ERROR_INCOMPATIBLE_DRIVER = -9,
        VK_ERROR_TOO_MANY_OBJECTS = -10,
        VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
        VK_ERROR_FRAGMENTED_POOL = -12,
        VK_ERROR_SURFACE_LOST_KHR = -1000000000,
        VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
        VK_SUBOPTIMAL_KHR = 1000001003,
        VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
        VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
        VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
        VK_ERROR_INVALID_SHADER_NV = -1000012000,
        VK_ERROR_OUT_OF_POOL_MEMORY_KHR = -1000069000,
        VK_RESULT_BEGIN_RANGE = -12,
        VK_RESULT_END_RANGE = 5,
        VK_RESULT_RANGE_SIZE = 18,
        VK_RESULT_MAX_ENUM = 2147483647
    }

    public enum Key
    {
        Unknown = -1,
        Space = 32,
        Apostrophe = 39,
        Comma = 44,
        Minus = 45,
        Period = 46,
        Slash = 47,
        _0 = 48,
        _1 = 49,
        _2 = 50,
        _3 = 51,
        _4 = 52,
        _5 = 53,
        _6 = 54,
        _7 = 55,
        _8 = 56,
        _9 = 57,
        Semicolon = 59,
        Equal = 61,
        A = 65,
        B = 66,
        C = 67,
        D = 68,
        E = 69,
        F = 70,
        G = 71,
        H = 72,
        I = 73,
        J = 74,
        K = 75,
        L = 76,
        M = 77,
        N = 78,
        O = 79,
        P = 80,
        Q = 81,
        R = 82,
        S = 83,
        T = 84,
        U = 85,
        V = 86,
        W = 87,
        X = 88,
        Y = 89,
        Z = 90,
        LeftBracket = 91,
        Backslash = 92,
        RightBracket = 93,
        GraveAccent = 96,
        World1 = 161,
        World2 = 162,
        Escape = 256,
        Enter = 257,
        Tab = 258,
        Backspace = 259,
        Insert = 260,
        Delete = 261,
        Right = 262,
        Left = 263,
        Down = 264,
        Up = 265,
        PageUp = 266,
        PageDown = 267,
        Home = 268,
        End = 269,
        CapsLock = 280,
        ScrollLock = 281,
        NumLock = 282,
        PrintScreen = 283,
        Pause = 284,
        F1 = 290,
        F2 = 291,
        F3 = 292,
        F4 = 293,
        F5 = 294,
        F6 = 295,
        F7 = 296,
        F8 = 297,
        F9 = 298,
        F10 = 299,
        F11 = 300,
        F12 = 301,
        F13 = 302,
        F14 = 303,
        F15 = 304,
        F16 = 305,
        F17 = 306,
        F18 = 307,
        F19 = 308,
        F20 = 309,
        F21 = 310,
        F22 = 311,
        F23 = 312,
        F24 = 313,
        F25 = 314,
        Kp0 = 320,
        Kp1 = 321,
        Kp2 = 322,
        Kp3 = 323,
        Kp4 = 324,
        Kp5 = 325,
        Kp6 = 326,
        Kp7 = 327,
        Kp8 = 328,
        Kp9 = 329,
        KpDecimal = 330,
        KpDivide = 331,
        KpMultiply = 332,
        KpSubtract = 333,
        KpAdd = 334,
        KpEnter = 335,
        KpEqual = 336,
        LeftShift = 340,
        LeftControl = 341,
        LeftAlt = 342,
        LeftSuper = 343,
        RightShift = 344,
        RightControl = 345,
        RightAlt = 346,
        RightSuper = 347,
        Menu = 348,
        Last = 348
    }

    public enum Mouse
    {
        _1 = 0,
        _2 = 1,
        _3 = 2,
        _4 = 3,
        _5 = 4,
        _6 = 5,
        _7 = 6,
        _8 = 7,
        _Last = 7,
        _Left = 0,
        _Right = 1,
        _Middle = 2
    }

    public enum Joystick
    {
        _1 = 0,
        _2 = 1,
        _3 = 2,
        _4 = 3,
        _5 = 4,
        _6 = 5,
        _7 = 6,
        _8 = 7,
        _9 = 8,
        _10 = 9,
        _11 = 10,
        _12 = 11,
        _13 = 12,
        _14 = 13,
        _15 = 14,
        _16 = 15,
        Last = 15
    }

    public enum KeyModifier
    {
        ModShift = 1,
        ModControl = 2,
        ModAlt = 4,
        ModSuper = 8
    }

    public enum Error
    {
        NotInitialized = 65537,
        NoCurrentContext = 65538,
        InvalidEnum = 65539,
        InvalidValue = 65540,
        OutOfMemory = 65541,
        ApiUnavailable = 65542,
        VersionUnavailable = 65543,
        PlatformError = 65544,
        FormatUnavailable = 65545,
        NoWindowContext = 65546
    }

    public enum State
    {
        True = 1,
        False = 0,
        Release = 0,
        Press = 1,
        Repeat = 2,
        Focused = 131073,
        Iconified = 131074,
        Resizable = 131075,
        Visible = 131076,
        Decorated = 131077,
        AutoIconify = 131078,
        Floating = 131079,
        Maximized = 131080,
        RedBits = 135169,
        GreenBits = 135170,
        BlueBits = 135171,
        AlphaBits = 135172,
        DepthBits = 135173,
        StencilBits = 135174,
        AccumRedBits = 135175,
        AccumGreenBits = 135176,
        AccumBlueBits = 135177,
        AccumAlphaBits = 135178,
        AuxBuffers = 135179,
        Stereo = 135180,
        Samples = 135181,
        SrgbCapable = 135182,
        RefreshRate = 135183,
        Doublebuffer = 135184,
        ClientApi = 139265,
        ContextVersionMajor = 139266,
        ContextVersionMinor = 139267,
        ContextRevision = 139268,
        ContextRobustness = 139269,
        OpenglForwardCompat = 139270,
        OpenglDebugContext = 139271,
        OpenglProfile = 139272,
        ContextReleaseBehavior = 139273,
        ContextNoError = 139274,
        ContextCreationApi = 139275,
        NoApi = 0,
        OpenglApi = 196609,
        OpenglEsApi = 196610,
        NoRobustness = 0,
        NoResetNotification = 200705,
        LoseContextOnReset = 200706,
        OpenglAnyProfile = 0,
        OpenglCoreProfile = 204801,
        OpenglCompatProfile = 204802,
        Cursor = 208897,
        StickyKeys = 208898,
        StickyMouseButtons = 208899,
        CursorNormal = 212993,
        CursorHidden = 212994,
        CursorDisabled = 212995,
        AnyReleaseBehavior = 0,
        ReleaseBehaviorFlush = 217089,
        ReleaseBehaviorNone = 217090,
        NativeContextApi = 221185,
        EglContextApi = 221186,
        Connected = 262145,
        Disconnected = 262146,
        DontCare = -1
    }

    public enum Version
    {
        VersionMajor = 3,
        VersionMinor = 2,
        VersionRevision = 1
    }

    /// <summary>
    ///   Generic function pointer used for returning client API function pointers
    ///   without forcing a cast from a regular pointer.
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWglproc();

    /// <summary>
    ///   Generic function pointer used for returning Vulkan API function pointers
    ///   without forcing a cast from a regular pointer.
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWvkproc();

    /// <summary>  Opaque monitor object.</summary>
    /// <summary>  Opaque window object.</summary>
    /// <summary>  Opaque cursor object.</summary>
    /// <summary>  This is the function signature for error callback functions.</summary>
    /// <param name="error">An [error code](</param>
    /// <param name="description">A UTF-8 encoded string describing the error.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWerrorfun(int _0, [MarshalAs(UnmanagedType.LPStr)] string _1);

    /// <summary>  This is the function signature for window position callback functions.</summary>
    /// <param name="window">The window that was moved.</param>
    /// <param name="xpos">
    /// The new x-coordinate, in screen coordinates, of the
    /// upper-left corner of the client area of the window.
    /// </param>
    /// <param name="ypos">
    /// The new y-coordinate, in screen coordinates, of the
    /// upper-left corner of the client area of the window.
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowposfun(global::System.IntPtr _0, int _1, int _2);

    /// <summary>  This is the function signature for window size callback functions.</summary>
    /// <param name="window">The window that was resized.</param>
    /// <param name="width">The new width, in screen coordinates, of the window.</param>
    /// <param name="height">The new height, in screen coordinates, of the window.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowsizefun(global::System.IntPtr _0, int _1, int _2);

    /// <summary>  This is the function signature for window close callback functions.</summary>
    /// <param name="window">The window that the user attempted to close.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowclosefun(global::System.IntPtr _0);

    /// <summary>  This is the function signature for window refresh callback functions.</summary>
    /// <param name="window">The window whose content needs to be refreshed.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowrefreshfun(global::System.IntPtr _0);

    /// <summary>  This is the function signature for window focus callback functions.</summary>
    /// <param name="window">The window that gained or lost input focus.</param>
    /// <param name="focused">
    /// `GLFW_TRUE` if the window was given input focus, or
    /// `GLFW_FALSE` if it lost it.
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowfocusfun(global::System.IntPtr _0, int _1);

    /// <summary>
    ///   This is the function signature for window iconify/restore callback
    ///   functions.
    /// </summary>
    /// <param name="window">The window that was iconified or restored.</param>
    /// <param name="iconified">
    /// `GLFW_TRUE` if the window was iconified, or
    /// `GLFW_FALSE` if it was restored.
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowiconifyfun(global::System.IntPtr _0, int _1);

    /// <summary>
    ///   This is the function signature for framebuffer resize callback
    ///   functions.
    /// </summary>
    /// <param name="window">The window whose framebuffer was resized.</param>
    /// <param name="width">The new width, in pixels, of the framebuffer.</param>
    /// <param name="height">The new height, in pixels, of the framebuffer.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWframebuffersizefun(global::System.IntPtr _0, int _1, int _2);

    /// <summary>  This is the function signature for mouse button callback functions.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="button">
    /// The [mouse button](
    /// released.
    /// </param>
    /// <param name="action">One of `GLFW_PRESS` or `GLFW_RELEASE`.</param>
    /// <param name="mods">
    /// Bit field describing which [modifier keys](
    /// held down.
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWmousebuttonfun(global::System.IntPtr _0, int _1, int _2, int _3);

    /// <summary>  This is the function signature for cursor position callback functions.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="xpos">
    /// The new cursor x-coordinate, relative to the left edge of
    /// the client area.
    /// </param>
    /// <param name="ypos">
    /// The new cursor y-coordinate, relative to the top edge of the
    /// client area.
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWcursorposfun(global::System.IntPtr _0, double _1, double _2);

    /// <summary>  This is the function signature for cursor enter/leave callback functions.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="entered">
    /// `GLFW_TRUE` if the cursor entered the window's client
    /// area, or `GLFW_FALSE` if it left it.
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWcursorenterfun(global::System.IntPtr _0, int _1);

    /// <summary>  This is the function signature for scroll callback functions.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="xoffset">The scroll offset along the x-axis.</param>
    /// <param name="yoffset">The scroll offset along the y-axis.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWscrollfun(global::System.IntPtr _0, double _1, double _2);

    /// <summary>  This is the function signature for keyboard key callback functions.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="key">The [keyboard key](</param>
    /// <param name="scancode">The system-specific scancode of the key.</param>
    /// <param name="action">`GLFW_PRESS`, `GLFW_RELEASE` or `GLFW_REPEAT`.</param>
    /// <param name="mods">
    /// Bit field describing which [modifier keys](
    /// held down.
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWkeyfun(global::System.IntPtr _0, int _1, int _2, int _3, int _4);

    /// <summary>  This is the function signature for Unicode character callback functions.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="codepoint">The Unicode code point of the character.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWcharfun(global::System.IntPtr _0, uint _1);

    /// <summary>
    ///   This is the function signature for Unicode character with modifiers callback
    ///   functions.  It is called for each input character, regardless of what
    ///   modifier keys are held down.
    /// </summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="codepoint">The Unicode code point of the character.</param>
    /// <param name="mods">
    /// Bit field describing which [modifier keys](
    /// held down.
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWcharmodsfun(global::System.IntPtr _0, uint _1, int _2);

    /// <summary>  This is the function signature for file drop callbacks.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="count">The number of dropped files.</param>
    /// <param name="paths">The UTF-8 encoded file and/or directory path names.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWdropfun(global::System.IntPtr _0, int _1, sbyte** _2);

    /// <summary>  This is the function signature for monitor configuration callback functions.</summary>
    /// <param name="monitor">The monitor that was connected or disconnected.</param>
    /// <param name="event">One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWmonitorfun(global::System.IntPtr _0, int _1);

    /// <summary>
    ///   This is the function signature for joystick configuration callback
    ///   functions.
    /// </summary>
    /// <param name="joy">The joystick that was connected or disconnected.</param>
    /// <param name="event">One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWjoystickfun(int _0, int _1);

    public unsafe partial class GLFWmonitor
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWmonitor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWmonitor>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::glfw3.GLFWmonitor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::glfw3.GLFWmonitor(native.ToPointer(), skipVTables);
        }

        internal static global::glfw3.GLFWmonitor __CreateInstance(global::glfw3.GLFWmonitor.__Internal native, bool skipVTables = false)
        {
            return new global::glfw3.GLFWmonitor(native, skipVTables);
        }

        private static void* __CopyValue(global::glfw3.GLFWmonitor.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWmonitor.__Internal));
            *(global::glfw3.GLFWmonitor.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWmonitor(global::glfw3.GLFWmonitor.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWmonitor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class GLFWwindow
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWwindow> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWwindow>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::glfw3.GLFWwindow __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::glfw3.GLFWwindow(native.ToPointer(), skipVTables);
        }

        internal static global::glfw3.GLFWwindow __CreateInstance(global::glfw3.GLFWwindow.__Internal native, bool skipVTables = false)
        {
            return new global::glfw3.GLFWwindow(native, skipVTables);
        }

        private static void* __CopyValue(global::glfw3.GLFWwindow.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWwindow.__Internal));
            *(global::glfw3.GLFWwindow.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWwindow(global::glfw3.GLFWwindow.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWwindow(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class GLFWcursor
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWcursor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWcursor>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::glfw3.GLFWcursor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::glfw3.GLFWcursor(native.ToPointer(), skipVTables);
        }

        internal static global::glfw3.GLFWcursor __CreateInstance(global::glfw3.GLFWcursor.__Internal native, bool skipVTables = false)
        {
            return new global::glfw3.GLFWcursor(native, skipVTables);
        }

        private static void* __CopyValue(global::glfw3.GLFWcursor.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWcursor.__Internal));
            *(global::glfw3.GLFWcursor.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWcursor(global::glfw3.GLFWcursor.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWcursor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>  This describes a single video mode.</summary>
    public unsafe partial class GLFWvidmode : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int width;

            [FieldOffset(4)]
            internal int height;

            [FieldOffset(8)]
            internal int redBits;

            [FieldOffset(12)]
            internal int greenBits;

            [FieldOffset(16)]
            internal int blueBits;

            [FieldOffset(20)]
            internal int refreshRate;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0GLFWvidmode@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWvidmode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWvidmode>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::glfw3.GLFWvidmode __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::glfw3.GLFWvidmode(native.ToPointer(), skipVTables);
        }

        internal static global::glfw3.GLFWvidmode __CreateInstance(global::glfw3.GLFWvidmode.__Internal native, bool skipVTables = false)
        {
            return new global::glfw3.GLFWvidmode(native, skipVTables);
        }

        private static void* __CopyValue(global::glfw3.GLFWvidmode.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWvidmode.__Internal));
            *(global::glfw3.GLFWvidmode.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWvidmode(global::glfw3.GLFWvidmode.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWvidmode(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public GLFWvidmode()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWvidmode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public GLFWvidmode(global::glfw3.GLFWvidmode _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWvidmode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::glfw3.GLFWvidmode.__Internal*) __Instance) = *((global::glfw3.GLFWvidmode.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::glfw3.GLFWvidmode __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Width
        {
            get
            {
                return ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->width;
            }

            set
            {
                ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->width = value;
            }
        }

        public int Height
        {
            get
            {
                return ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->height;
            }

            set
            {
                ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->height = value;
            }
        }

        public int RedBits
        {
            get
            {
                return ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->redBits;
            }

            set
            {
                ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->redBits = value;
            }
        }

        public int GreenBits
        {
            get
            {
                return ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->greenBits;
            }

            set
            {
                ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->greenBits = value;
            }
        }

        public int BlueBits
        {
            get
            {
                return ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->blueBits;
            }

            set
            {
                ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->blueBits = value;
            }
        }

        public int RefreshRate
        {
            get
            {
                return ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->refreshRate;
            }

            set
            {
                ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->refreshRate = value;
            }
        }
    }

    /// <summary>  This describes the gamma ramp for a monitor.</summary>
    public unsafe partial class GLFWgammaramp : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr red;

            [FieldOffset(4)]
            internal global::System.IntPtr green;

            [FieldOffset(8)]
            internal global::System.IntPtr blue;

            [FieldOffset(12)]
            internal uint size;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0GLFWgammaramp@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWgammaramp> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWgammaramp>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::glfw3.GLFWgammaramp __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::glfw3.GLFWgammaramp(native.ToPointer(), skipVTables);
        }

        internal static global::glfw3.GLFWgammaramp __CreateInstance(global::glfw3.GLFWgammaramp.__Internal native, bool skipVTables = false)
        {
            return new global::glfw3.GLFWgammaramp(native, skipVTables);
        }

        private static void* __CopyValue(global::glfw3.GLFWgammaramp.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWgammaramp.__Internal));
            *(global::glfw3.GLFWgammaramp.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWgammaramp(global::glfw3.GLFWgammaramp.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWgammaramp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public GLFWgammaramp()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWgammaramp.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public GLFWgammaramp(global::glfw3.GLFWgammaramp _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWgammaramp.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::glfw3.GLFWgammaramp.__Internal*) __Instance) = *((global::glfw3.GLFWgammaramp.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::glfw3.GLFWgammaramp __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort* Red
        {
            get
            {
                return (ushort*) ((global::glfw3.GLFWgammaramp.__Internal*) __Instance)->red;
            }

            set
            {
                ((global::glfw3.GLFWgammaramp.__Internal*) __Instance)->red = (global::System.IntPtr) value;
            }
        }

        public ushort* Green
        {
            get
            {
                return (ushort*) ((global::glfw3.GLFWgammaramp.__Internal*) __Instance)->green;
            }

            set
            {
                ((global::glfw3.GLFWgammaramp.__Internal*) __Instance)->green = (global::System.IntPtr) value;
            }
        }

        public ushort* Blue
        {
            get
            {
                return (ushort*) ((global::glfw3.GLFWgammaramp.__Internal*) __Instance)->blue;
            }

            set
            {
                ((global::glfw3.GLFWgammaramp.__Internal*) __Instance)->blue = (global::System.IntPtr) value;
            }
        }

        public uint Size
        {
            get
            {
                return ((global::glfw3.GLFWgammaramp.__Internal*) __Instance)->size;
            }

            set
            {
                ((global::glfw3.GLFWgammaramp.__Internal*) __Instance)->size = value;
            }
        }
    }


    public unsafe partial class GLFWimage : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int width;

            [FieldOffset(4)]
            internal int height;

            [FieldOffset(8)]
            internal global::System.IntPtr pixels;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0GLFWimage@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWimage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWimage>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::glfw3.GLFWimage __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::glfw3.GLFWimage(native.ToPointer(), skipVTables);
        }

        internal static global::glfw3.GLFWimage __CreateInstance(global::glfw3.GLFWimage.__Internal native, bool skipVTables = false)
        {
            return new global::glfw3.GLFWimage(native, skipVTables);
        }

        private static void* __CopyValue(global::glfw3.GLFWimage.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWimage.__Internal));
            *(global::glfw3.GLFWimage.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWimage(global::glfw3.GLFWimage.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWimage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public GLFWimage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWimage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public GLFWimage(global::glfw3.GLFWimage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWimage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::glfw3.GLFWimage.__Internal*) __Instance) = *((global::glfw3.GLFWimage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::glfw3.GLFWimage __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Width
        {
            get
            {
                return ((global::glfw3.GLFWimage.__Internal*) __Instance)->width;
            }

            set
            {
                ((global::glfw3.GLFWimage.__Internal*) __Instance)->width = value;
            }
        }

        public int Height
        {
            get
            {
                return ((global::glfw3.GLFWimage.__Internal*) __Instance)->height;
            }

            set
            {
                ((global::glfw3.GLFWimage.__Internal*) __Instance)->height = value;
            }
        }

        public byte* Pixels
        {
            get
            {
                return (byte*) ((global::glfw3.GLFWimage.__Internal*) __Instance)->pixels;
            }

            set
            {
                ((global::glfw3.GLFWimage.__Internal*) __Instance)->pixels = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class Test : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Test@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.Test> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.Test>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::glfw3.Test __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::glfw3.Test(native.ToPointer(), skipVTables);
        }

        internal static global::glfw3.Test __CreateInstance(global::glfw3.Test.__Internal native, bool skipVTables = false)
        {
            return new global::glfw3.Test(native, skipVTables);
        }

        private static void* __CopyValue(global::glfw3.Test.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::glfw3.Test.__Internal));
            *(global::glfw3.Test.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Test(global::glfw3.Test.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Test(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Test()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::glfw3.Test.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Test(global::glfw3.Test _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::glfw3.Test.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::glfw3.Test.__Internal*) __Instance) = *((global::glfw3.Test.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::glfw3.Test __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }

    public unsafe partial class Glfw
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwInit")]
            internal static extern int Init_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwTerminate")]
            internal static extern void Terminate_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="getTests")]
            internal static extern global::System.IntPtr GetTests_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetVersion")]
            internal static extern void GetVersion_0(int* major, int* minor, int* rev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetVersionString")]
            internal static extern global::System.IntPtr GetVersionString_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetErrorCallback")]
            internal static extern global::System.IntPtr SetErrorCallback_0(global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetMonitors")]
            internal static extern global::System.IntPtr GetMonitors_0(int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetPrimaryMonitor")]
            internal static extern global::System.IntPtr GetPrimaryMonitor_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetMonitorPos")]
            internal static extern void GetMonitorPos_0(global::System.IntPtr monitor, int* xpos, int* ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetMonitorPhysicalSize")]
            internal static extern void GetMonitorPhysicalSize_0(global::System.IntPtr monitor, int* widthMM, int* heightMM);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetMonitorName")]
            internal static extern global::System.IntPtr GetMonitorName_0(global::System.IntPtr monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetMonitorCallback")]
            internal static extern global::System.IntPtr SetMonitorCallback_0(global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetVideoModes")]
            internal static extern global::System.IntPtr GetVideoModes_0(global::System.IntPtr monitor, int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetVideoMode")]
            internal static extern global::System.IntPtr GetVideoMode_0(global::System.IntPtr monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetGamma")]
            internal static extern void SetGamma_0(global::System.IntPtr monitor, float gamma);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetGammaRamp")]
            internal static extern global::System.IntPtr GetGammaRamp_0(global::System.IntPtr monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetGammaRamp")]
            internal static extern void SetGammaRamp_0(global::System.IntPtr monitor, global::System.IntPtr ramp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwDefaultWindowHints")]
            internal static extern void DefaultWindowHints_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwWindowHint")]
            internal static extern void WindowHint_0(int hint, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwCreateWindow")]
            internal static extern global::System.IntPtr CreateWindow_0(int width, int height, [MarshalAs(UnmanagedType.LPStr)] string title, global::System.IntPtr monitor, global::System.IntPtr share);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwDestroyWindow")]
            internal static extern void DestroyWindow_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwWindowShouldClose")]
            internal static extern int WindowShouldClose_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowShouldClose")]
            internal static extern void SetWindowShouldClose_0(global::System.IntPtr window, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowTitle")]
            internal static extern void SetWindowTitle_0(global::System.IntPtr window, [MarshalAs(UnmanagedType.LPStr)] string title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowIcon")]
            internal static extern void SetWindowIcon_0(global::System.IntPtr window, int count, global::System.IntPtr images);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowPos")]
            internal static extern void GetWindowPos_0(global::System.IntPtr window, int* xpos, int* ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowPos")]
            internal static extern void SetWindowPos_0(global::System.IntPtr window, int xpos, int ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowSize")]
            internal static extern void GetWindowSize_0(global::System.IntPtr window, int* width, int* height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowSizeLimits")]
            internal static extern void SetWindowSizeLimits_0(global::System.IntPtr window, int minwidth, int minheight, int maxwidth, int maxheight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowAspectRatio")]
            internal static extern void SetWindowAspectRatio_0(global::System.IntPtr window, int numer, int denom);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowSize")]
            internal static extern void SetWindowSize_0(global::System.IntPtr window, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetFramebufferSize")]
            internal static extern void GetFramebufferSize_0(global::System.IntPtr window, int* width, int* height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowFrameSize")]
            internal static extern void GetWindowFrameSize_0(global::System.IntPtr window, int* left, int* top, int* right, int* bottom);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwIconifyWindow")]
            internal static extern void IconifyWindow_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwRestoreWindow")]
            internal static extern void RestoreWindow_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwMaximizeWindow")]
            internal static extern void MaximizeWindow_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwShowWindow")]
            internal static extern void ShowWindow_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwHideWindow")]
            internal static extern void HideWindow_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwFocusWindow")]
            internal static extern void FocusWindow_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowMonitor")]
            internal static extern global::System.IntPtr GetWindowMonitor_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowMonitor")]
            internal static extern void SetWindowMonitor_0(global::System.IntPtr window, global::System.IntPtr monitor, int xpos, int ypos, int width, int height, int refreshRate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowAttrib")]
            internal static extern int GetWindowAttrib_0(global::System.IntPtr window, int attrib);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowUserPointer")]
            internal static extern void SetWindowUserPointer_0(global::System.IntPtr window, global::System.IntPtr pointer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowUserPointer")]
            internal static extern global::System.IntPtr GetWindowUserPointer_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowPosCallback")]
            internal static extern global::System.IntPtr SetWindowPosCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowSizeCallback")]
            internal static extern global::System.IntPtr SetWindowSizeCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowCloseCallback")]
            internal static extern global::System.IntPtr SetWindowCloseCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowRefreshCallback")]
            internal static extern global::System.IntPtr SetWindowRefreshCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowFocusCallback")]
            internal static extern global::System.IntPtr SetWindowFocusCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowIconifyCallback")]
            internal static extern global::System.IntPtr SetWindowIconifyCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetFramebufferSizeCallback")]
            internal static extern global::System.IntPtr SetFramebufferSizeCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwPollEvents")]
            internal static extern void PollEvents_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwWaitEvents")]
            internal static extern void WaitEvents_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwWaitEventsTimeout")]
            internal static extern void WaitEventsTimeout_0(double timeout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwPostEmptyEvent")]
            internal static extern void PostEmptyEvent_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetInputMode")]
            internal static extern int GetInputMode_0(global::System.IntPtr window, int mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetInputMode")]
            internal static extern void SetInputMode_0(global::System.IntPtr window, int mode, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetKeyName")]
            internal static extern global::System.IntPtr GetKeyName_0(int key, int scancode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetKey")]
            internal static extern int GetKey_0(global::System.IntPtr window, int key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetMouseButton")]
            internal static extern int GetMouseButton_0(global::System.IntPtr window, int button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetCursorPos")]
            internal static extern void GetCursorPos_0(global::System.IntPtr window, double* xpos, double* ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCursorPos")]
            internal static extern void SetCursorPos_0(global::System.IntPtr window, double xpos, double ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwCreateCursor")]
            internal static extern global::System.IntPtr CreateCursor_0(global::System.IntPtr image, int xhot, int yhot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwCreateStandardCursor")]
            internal static extern global::System.IntPtr CreateStandardCursor_0(int shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwDestroyCursor")]
            internal static extern void DestroyCursor_0(global::System.IntPtr cursor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCursor")]
            internal static extern void SetCursor_0(global::System.IntPtr window, global::System.IntPtr cursor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetKeyCallback")]
            internal static extern global::System.IntPtr SetKeyCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCharCallback")]
            internal static extern global::System.IntPtr SetCharCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCharModsCallback")]
            internal static extern global::System.IntPtr SetCharModsCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetMouseButtonCallback")]
            internal static extern global::System.IntPtr SetMouseButtonCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCursorPosCallback")]
            internal static extern global::System.IntPtr SetCursorPosCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCursorEnterCallback")]
            internal static extern global::System.IntPtr SetCursorEnterCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetScrollCallback")]
            internal static extern global::System.IntPtr SetScrollCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetDropCallback")]
            internal static extern global::System.IntPtr SetDropCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwJoystickPresent")]
            internal static extern int JoystickPresent_0(int joy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetJoystickAxes")]
            internal static extern float* GetJoystickAxes_0(int joy, int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetJoystickButtons")]
            internal static extern byte* GetJoystickButtons_0(int joy, int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetJoystickName")]
            internal static extern global::System.IntPtr GetJoystickName_0(int joy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetJoystickCallback")]
            internal static extern global::System.IntPtr SetJoystickCallback_0(global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetClipboardString")]
            internal static extern void SetClipboardString_0(global::System.IntPtr window, [MarshalAs(UnmanagedType.LPStr)] string @string);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetClipboardString")]
            internal static extern global::System.IntPtr GetClipboardString_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetTime")]
            internal static extern double GetTime_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetTime")]
            internal static extern void SetTime_0(double time);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetTimerValue")]
            internal static extern ulong GetTimerValue_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetTimerFrequency")]
            internal static extern ulong GetTimerFrequency_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwMakeContextCurrent")]
            internal static extern void MakeContextCurrent_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetCurrentContext")]
            internal static extern global::System.IntPtr GetCurrentContext_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSwapBuffers")]
            internal static extern void SwapBuffers_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSwapInterval")]
            internal static extern void SwapInterval_0(int interval);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwExtensionSupported")]
            internal static extern int ExtensionSupported_0([MarshalAs(UnmanagedType.LPStr)] string extension);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetProcAddress")]
            internal static extern global::System.IntPtr GetProcAddress_0([MarshalAs(UnmanagedType.LPStr)] string procname);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwVulkanSupported")]
            internal static extern int VulkanSupported_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetRequiredInstanceExtensions")]
            internal static extern sbyte** GetRequiredInstanceExtensions_0(uint* count);
        }

        /// <summary>
        ///   This function initializes the GLFW library.  Before most GLFW functions can
        ///   be used, GLFW must be initialized, and before an application terminates GLFW
        ///   should be terminated in order to free any resources allocated during or
        ///   after initialization.
        ///   If this function fails, it calls 
        ///   succeeds, you should call 
        ///   Additional calls to this function after successful initialization but before
        ///   termination will return `GLFW_TRUE` immediately.
        /// </summary>
        /// <returns>
        /// `GLFW_TRUE` if successful, or `GLFW_FALSE` if an
        /// [error](
        /// 
        /// Possible errors include
        /// 
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static int Init()
        {
            var __ret = __Internal.Init_0();
            return __ret;
        }

        /// <summary>
        ///   This function destroys all remaining windows and cursors, restores any
        ///   modified gamma ramps and frees any other allocated resources.  Once this
        ///   function is called, you must again call 
        ///   you will be able to use most GLFW functions.
        ///   If GLFW has been successfully initialized, this function should be called
        ///   before the application exits.  If initialization fails, there is no need to
        ///   call this function, as it is called by 
        ///   failure.
        ///   
        /// Possible errors include 
        ///   
        ///   
        ///   
        /// This function must not be called from a callback.
        ///   
        /// _safety This function must only be called from the main thread.
        /// </summary>
        public static void Terminate()
        {
            __Internal.Terminate_0();
        }

        public static global::glfw3.Test GetTests()
        {
            var __ret = __Internal.GetTests_0();
            global::glfw3.Test __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.Test.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.Test) global::glfw3.Test.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.Test.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        ///   This function retrieves the major, minor and revision numbers of the GLFW
        ///   library.  It is intended for when you are using GLFW as a shared library and
        ///   want to ensure that you are using the minimum required version.
        ///   Any or all of the version arguments may be `NULL`.
        /// </summary>
        /// <param name="major">Where to store the major version number, or `NULL`.</param>
        /// <param name="minor">Where to store the minor version number, or `NULL`.</param>
        /// <param name="rev">
        /// Where to store the revision number, or `NULL`.
        /// 
        /// None.
        /// 
        /// 
        /// _safety This function may be called from any thread.
        /// </param>
        public static void GetVersion(ref int major, ref int minor, ref int rev)
        {
            fixed (int* __refParamPtr0 = &major)
            {
                var __arg0 = __refParamPtr0;
                fixed (int* __refParamPtr1 = &minor)
                {
                    var __arg1 = __refParamPtr1;
                    fixed (int* __refParamPtr2 = &rev)
                    {
                        var __arg2 = __refParamPtr2;
                        __Internal.GetVersion_0(__arg0, __arg1, __arg2);
                    }
                }
            }
        }

        /// <summary>
        ///   This function returns the compile-time generated
        ///   [version string](
        ///   describes the version, platform, compiler and any platform-specific
        ///   compile-time options.  It should not be confused with the OpenGL or OpenGL
        ///   ES version string, queried with `glGetString`.
        ///   __Do not use the version string__ to parse the GLFW library version.  The
        ///   
        ///   binary in numerical format.
        /// </summary>
        /// <returns>
        /// The ASCII encoded GLFW version string.
        /// 
        /// None.
        /// 
        /// 
        /// _lifetime The returned string is static and compile-time generated.
        /// 
        /// _safety This function may be called from any thread.
        /// </returns>
        public static string GetVersionString()
        {
            var __ret = __Internal.GetVersionString_0();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        ///   This function sets the error callback, which is called with an error code
        ///   and a human-readable description each time a GLFW error occurs.
        ///   The error callback is called on the thread where the error occurred.  If you
        ///   are using GLFW from multiple threads, your error callback needs to be
        ///   written accordingly.
        ///   Because the description string may have been generated specifically for that
        ///   error, it is not guaranteed to be valid after the callback has returned.  If
        ///   you wish to use it after the callback returns, you need to make a copy.
        ///   Once set, the error callback remains set even after the library has been
        ///   terminated.
        /// </summary>
        /// <param name="cbfun">
        /// The new callback, or `NULL` to remove the currently set
        /// callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set.
        /// 
        /// None.
        /// 
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWerrorfun SetErrorCallback(global::glfw3.GLFWerrorfun cbfun)
        {
            var __arg0 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetErrorCallback_0(__arg0);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWerrorfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWerrorfun));
        }

        /// <summary>
        ///   This function returns an array of handles for all currently connected
        ///   monitors.  The primary monitor is always first in the returned array.  If no
        ///   monitors were found, this function returns `NULL`.
        /// </summary>
        /// <param name="count">
        /// Where to store the number of monitors in the returned
        /// array.  This is set to zero if an error occurred.
        /// </param>
        /// <returns>
        /// An array of monitor handles, or `NULL` if no monitors were found or
        /// if an [error](
        /// 
        /// Possible errors include
        /// 
        /// _lifetime The returned array is allocated and freed by GLFW.  You
        /// should not free it yourself.  It is guaranteed to be valid only until the
        /// monitor configuration changes or the library is terminated.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWmonitor GetMonitors(ref int count)
        {
            fixed (int* __refParamPtr0 = &count)
            {
                var __arg0 = __refParamPtr0;
                var __ret = __Internal.GetMonitors_0(__arg0);
                global::glfw3.GLFWmonitor __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::glfw3.GLFWmonitor.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::glfw3.GLFWmonitor) global::glfw3.GLFWmonitor.NativeToManagedMap[__ret];
                else __result0 = global::glfw3.GLFWmonitor.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>
        ///   This function returns the primary monitor.  This is usually the monitor
        ///   where elements like the task bar or global menu bar are located.
        /// </summary>
        /// <returns>
        /// The primary monitor, or `NULL` if no monitors were found or if an
        /// [error](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// 
        /// glfwGetMonitors.
        /// </returns>
        public static global::glfw3.GLFWmonitor GetPrimaryMonitor()
        {
            var __ret = __Internal.GetPrimaryMonitor_0();
            global::glfw3.GLFWmonitor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.GLFWmonitor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.GLFWmonitor) global::glfw3.GLFWmonitor.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.GLFWmonitor.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        ///   This function returns the position, in screen coordinates, of the upper-left
        ///   corner of the specified monitor.
        ///   Any or all of the position arguments may be `NULL`.  If an error occurs, all
        ///   non-`NULL` position arguments will be set to zero.
        /// </summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <param name="xpos">Where to store the monitor x-coordinate, or `NULL`.</param>
        /// <param name="ypos">
        /// Where to store the monitor y-coordinate, or `NULL`.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void GetMonitorPos(global::glfw3.GLFWmonitor monitor, ref int xpos, ref int ypos)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            fixed (int* __refParamPtr1 = &xpos)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &ypos)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GetMonitorPos_0(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>
        ///   This function returns the size, in millimetres, of the display area of the
        ///   specified monitor.
        ///   Some systems do not provide accurate monitor size information, either
        ///   because the monitor
        ///   [EDID](https://en.wikipedia.org/wiki/Extended_display_identification_data)
        ///   data is incorrect or because the driver does not report it accurately.
        ///   Any or all of the size arguments may be `NULL`.  If an error occurs, all
        ///   non-`NULL` size arguments will be set to zero.
        /// </summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <param name="widthMM">
        /// Where to store the width, in millimetres, of the
        /// monitor's display area, or `NULL`.
        /// </param>
        /// <param name="heightMM">
        /// Where to store the height, in millimetres, of the
        /// monitor's display area, or `NULL`.
        /// 
        /// Possible errors include
        /// 
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void GetMonitorPhysicalSize(global::glfw3.GLFWmonitor monitor, ref int widthMM, ref int heightMM)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            fixed (int* __refParamPtr1 = &widthMM)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &heightMM)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GetMonitorPhysicalSize_0(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>
        ///   This function returns a human-readable name, encoded as UTF-8, of the
        ///   specified monitor.  The name typically reflects the make and model of the
        ///   monitor and is not guaranteed to be unique among the connected monitors.
        /// </summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <returns>
        /// The UTF-8 encoded name of the monitor, or `NULL` if an
        /// [error](
        /// 
        /// Possible errors include
        /// 
        /// _lifetime The returned string is allocated and freed by GLFW.  You
        /// should not free it yourself.  It is valid until the specified monitor is
        /// disconnected or the library is terminated.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static string GetMonitorName(global::glfw3.GLFWmonitor monitor)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            var __ret = __Internal.GetMonitorName_0(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        ///   This function sets the monitor configuration callback, or removes the
        ///   currently set callback.  This is called when a monitor is connected to or
        ///   disconnected from the system.
        /// </summary>
        /// <param name="cbfun">
        /// The new callback, or `NULL` to remove the currently set
        /// callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set or the
        /// library had not been [initialized](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWmonitorfun SetMonitorCallback(global::glfw3.GLFWmonitorfun cbfun)
        {
            var __arg0 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetMonitorCallback_0(__arg0);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWmonitorfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWmonitorfun));
        }

        /// <summary>
        ///   This function returns an array of all video modes supported by the specified
        ///   monitor.  The returned array is sorted in ascending order, first by color
        ///   bit depth (the sum of all channel depths) and then by resolution area (the
        ///   product of width and height).
        /// </summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <param name="count">
        /// Where to store the number of video modes in the returned
        /// array.  This is set to zero if an error occurred.
        /// </param>
        /// <returns>
        /// An array of video modes, or `NULL` if an
        /// [error](
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _lifetime The returned array is allocated and freed by GLFW.  You
        /// should not free it yourself.  It is valid until the specified monitor is
        /// disconnected, this function is called again for that monitor or the library
        /// is terminated.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWvidmode GetVideoModes(global::glfw3.GLFWmonitor monitor, ref int count)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            fixed (int* __refParamPtr1 = &count)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.GetVideoModes_0(__arg0, __arg1);
                global::glfw3.GLFWvidmode __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::glfw3.GLFWvidmode.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::glfw3.GLFWvidmode) global::glfw3.GLFWvidmode.NativeToManagedMap[__ret];
                else __result0 = global::glfw3.GLFWvidmode.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>
        ///   This function returns the current video mode of the specified monitor.  If
        ///   you have created a full screen window for that monitor, the return value
        ///   will depend on whether that window is iconified.
        /// </summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <returns>
        /// The current mode of the monitor, or `NULL` if an
        /// [error](
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _lifetime The returned array is allocated and freed by GLFW.  You
        /// should not free it yourself.  It is valid until the specified monitor is
        /// disconnected or the library is terminated.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWvidmode GetVideoMode(global::glfw3.GLFWmonitor monitor)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            var __ret = __Internal.GetVideoMode_0(__arg0);
            global::glfw3.GLFWvidmode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.GLFWvidmode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.GLFWvidmode) global::glfw3.GLFWvidmode.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.GLFWvidmode.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        ///   This function generates a 256-element gamma ramp from the specified exponent
        ///   and then calls 
        ///   number greater than zero.
        /// </summary>
        /// <param name="monitor">The monitor whose gamma ramp to set.</param>
        /// <param name="gamma">
        /// The desired exponent.
        /// 
        /// Possible errors include
        /// GLFW_INVALID_VALUE and
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void SetGamma(global::glfw3.GLFWmonitor monitor, float gamma)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            __Internal.SetGamma_0(__arg0, gamma);
        }

        /// <summary>  This function returns the current gamma ramp of the specified monitor.</summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <returns>
        /// The current gamma ramp, or `NULL` if an
        /// [error](
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _lifetime The returned structure and its arrays are allocated and
        /// freed by GLFW.  You should not free them yourself.  They are valid until the
        /// specified monitor is disconnected, this function is called again for that
        /// monitor or the library is terminated.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWgammaramp GetGammaRamp(global::glfw3.GLFWmonitor monitor)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            var __ret = __Internal.GetGammaRamp_0(__arg0);
            global::glfw3.GLFWgammaramp __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.GLFWgammaramp.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.GLFWgammaramp) global::glfw3.GLFWgammaramp.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.GLFWgammaramp.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        ///   This function sets the current gamma ramp for the specified monitor.  The
        ///   original gamma ramp for that monitor is saved by GLFW the first time this
        ///   function is called and is restored by 
        /// </summary>
        /// <param name="monitor">The monitor whose gamma ramp to set.</param>
        /// <param name="ramp">
        /// The gamma ramp to use.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// 
        /// 
        /// _lifetime The specified gamma ramp is copied before this function
        /// returns.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void SetGammaRamp(global::glfw3.GLFWmonitor monitor, global::glfw3.GLFWgammaramp ramp)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            var __arg1 = ReferenceEquals(ramp, null) ? global::System.IntPtr.Zero : ramp.__Instance;
            __Internal.SetGammaRamp_0(__arg0, __arg1);
        }

        /// <summary>
        ///   This function resets all window hints to their
        ///   [default values](
        ///   
        /// Possible errors include 
        ///   
        /// _safety This function must only be called from the main thread.
        /// </summary>
        public static void DefaultWindowHints()
        {
            __Internal.DefaultWindowHints_0();
        }

        /// <summary>
        ///   This function sets hints for the next call to 
        ///   hints, once set, retain their values until changed by a call to 
        ///   glfwWindowHint or 
        ///   terminated.
        ///   This function does not check whether the specified hint values are valid.
        ///   If you set hints to invalid values this will instead be reported by the next
        ///   call to 
        /// </summary>
        /// <param name="hint">The [window hint](</param>
        /// <param name="value">
        /// The new value of the window hint.
        /// 
        /// Possible errors include
        /// GLFW_INVALID_ENUM.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void WindowHint(int hint, int value)
        {
            __Internal.WindowHint_0(hint, value);
        }

        /// <summary>
        ///   This function creates a window and its associated OpenGL or OpenGL ES
        ///   context.  Most of the options controlling how the window and its context
        ///   should be created are specified with [window hints](
        ///   Successful creation does not change which context is current.  Before you
        ///   can use the newly created context, you need to
        ///   [make it current](
        ///   parameter, see 
        ///   The created window, framebuffer and context may differ from what you
        ///   requested, as not all parameters and hints are
        ///   [hard constraints](
        ///   window, especially for full screen windows.  To query the actual attributes
        ///   of the created window, framebuffer and context, see 
        ///   glfwGetWindowAttrib, 
        ///   To create a full screen window, you need to specify the monitor the window
        ///   will cover.  If no monitor is specified, the window will be windowed mode.
        ///   Unless you have a way for the user to choose a specific monitor, it is
        ///   recommended that you pick the primary monitor.  For more information on how
        ///   to query connected monitors, see 
        ///   For full screen windows, the specified size becomes the resolution of the
        ///   window's _desired video mode_.  As long as a full screen window is not
        ///   iconified, the supported video mode most closely matching the desired video
        ///   mode is set for the specified monitor.  For more information about full
        ///   screen windows, including the creation of so called _windowed full screen_
        ///   or _borderless full screen_ windows, see 
        ///   Once you have created the window, you can switch it between windowed and
        ///   full screen mode with 
        ///   OpenGL or OpenGL ES context, it will be unaffected.
        ///   By default, newly created windows use the placement recommended by the
        ///   window system.  To create the window at a specific position, make it
        ///   initially invisible using the [GLFW_VISIBLE](
        ///   hint, set its [position](
        ///   it.
        ///   As long as at least one full screen window is not iconified, the screensaver
        ///   is prohibited from starting.
        ///   Window systems put limits on window sizes.  Very large or very small window
        ///   dimensions may be overridden by the window system on creation.  Check the
        ///   actual [size](
        ///   The [swap interval](
        ///   the initial value may vary depending on driver settings and defaults.
        /// </summary>
        /// <param name="width">
        /// The desired width, in screen coordinates, of the window.
        /// This must be greater than zero.
        /// </param>
        /// <param name="height">
        /// The desired height, in screen coordinates, of the window.
        /// This must be greater than zero.
        /// </param>
        /// <param name="title">The initial, UTF-8 encoded window title.</param>
        /// <param name="monitor">
        /// The monitor to use for full screen mode, or `NULL` for
        /// windowed mode.
        /// </param>
        /// <param name="share">
        /// The window whose context to share resources with, or `NULL`
        /// to not share resources.
        /// </param>
        /// <returns>
        /// The handle of the created window, or `NULL` if an
        /// [error](
        /// 
        /// Possible errors include
        /// GLFW_INVALID_ENUM,
        /// GLFW_VERSION_UNAVAILABLE,
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// This function must not be called from a callback.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWwindow CreateWindow(int width, int height, string title, global::glfw3.GLFWmonitor monitor, global::glfw3.GLFWwindow share)
        {
            var __arg3 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            var __arg4 = ReferenceEquals(share, null) ? global::System.IntPtr.Zero : share.__Instance;
            var __ret = __Internal.CreateWindow_0(width, height, title, __arg3, __arg4);
            global::glfw3.GLFWwindow __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.GLFWwindow.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.GLFWwindow) global::glfw3.GLFWwindow.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.GLFWwindow.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        ///   This function destroys the specified window and its context.  On calling
        ///   this function, no further callbacks will be called for that window.
        ///   If the context of the specified window is current on the main thread, it is
        ///   detached before being destroyed.
        /// </summary>
        /// <param name="window">
        /// The window to destroy.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// 
        /// This function must not be called from a callback.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void DestroyWindow(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.DestroyWindow_0(__arg0);
        }

        /// <summary>  This function returns the value of the close flag of the specified window.</summary>
        /// <param name="window">The window to query.</param>
        /// <returns>
        /// The value of the close flag.
        /// 
        /// Possible errors include
        /// 
        /// _safety This function may be called from any thread.  Access is not
        /// synchronized.
        /// </returns>
        public static int WindowShouldClose(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.WindowShouldClose_0(__arg0);
            return __ret;
        }

        /// <summary>
        ///   This function sets the value of the close flag of the specified window.
        ///   This can be used to override the user's attempt to close the window, or
        ///   to signal that it should be closed.
        /// </summary>
        /// <param name="window">The window whose flag to change.</param>
        /// <param name="value">
        /// The new value.
        /// 
        /// Possible errors include
        /// 
        /// _safety This function may be called from any thread.  Access is not
        /// synchronized.
        /// </param>
        public static void SetWindowShouldClose(global::glfw3.GLFWwindow window, int value)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetWindowShouldClose_0(__arg0, value);
        }

        /// <summary>
        ///   This function sets the window title, encoded as UTF-8, of the specified
        ///   window.
        /// </summary>
        /// <param name="window">The window whose title to change.</param>
        /// <param name="title">
        /// The UTF-8 encoded window title.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void SetWindowTitle(global::glfw3.GLFWwindow window, string title)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetWindowTitle_0(__arg0, title);
        }

        /// <summary>
        ///   This function sets the icon of the specified window.  If passed an array of
        ///   candidate images, those of or closest to the sizes desired by the system are
        ///   selected.  If no images are specified, the window reverts to its default
        ///   icon.
        ///   The desired image sizes varies depending on platform and system settings.
        ///   The selected images will be rescaled as needed.  Good sizes include 16x16,
        ///   32x32 and 48x48.
        /// </summary>
        /// <param name="window">The window whose icon to set.</param>
        /// <param name="count">
        /// The number of images in the specified array, or zero to
        /// revert to the default window icon.
        /// </param>
        /// <param name="images">
        /// The images to create the icon from.  This is ignored if
        /// count is zero.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _lifetime The specified image data is copied before this function
        /// returns.
        /// 
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void SetWindowIcon(global::glfw3.GLFWwindow window, int count, global::glfw3.GLFWimage images)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg2 = ReferenceEquals(images, null) ? global::System.IntPtr.Zero : images.__Instance;
            __Internal.SetWindowIcon_0(__arg0, count, __arg2);
        }

        /// <summary>
        ///   This function retrieves the position, in screen coordinates, of the
        ///   upper-left corner of the client area of the specified window.
        ///   Any or all of the position arguments may be `NULL`.  If an error occurs, all
        ///   non-`NULL` position arguments will be set to zero.
        /// </summary>
        /// <param name="window">The window to query.</param>
        /// <param name="xpos">
        /// Where to store the x-coordinate of the upper-left corner of
        /// the client area, or `NULL`.
        /// </param>
        /// <param name="ypos">
        /// Where to store the y-coordinate of the upper-left corner of
        /// the client area, or `NULL`.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void GetWindowPos(global::glfw3.GLFWwindow window, ref int xpos, ref int ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __refParamPtr1 = &xpos)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &ypos)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GetWindowPos_0(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>
        ///   This function sets the position, in screen coordinates, of the upper-left
        ///   corner of the client area of the specified windowed mode window.  If the
        ///   window is a full screen window, this function does nothing.
        ///   __Do not use this function__ to move an already visible window unless you
        ///   have very good reasons for doing so, as it will confuse and annoy the user.
        ///   The window manager may put limits on what positions are allowed.  GLFW
        ///   cannot and should not override these limits.
        /// </summary>
        /// <param name="window">The window to query.</param>
        /// <param name="xpos">The x-coordinate of the upper-left corner of the client area.</param>
        /// <param name="ypos">
        /// The y-coordinate of the upper-left corner of the client area.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void SetWindowPos(global::glfw3.GLFWwindow window, int xpos, int ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetWindowPos_0(__arg0, xpos, ypos);
        }

        /// <summary>
        ///   This function retrieves the size, in screen coordinates, of the client area
        ///   of the specified window.  If you wish to retrieve the size of the
        ///   framebuffer of the window in pixels, see 
        ///   Any or all of the size arguments may be `NULL`.  If an error occurs, all
        ///   non-`NULL` size arguments will be set to zero.
        /// </summary>
        /// <param name="window">The window whose size to retrieve.</param>
        /// <param name="width">
        /// Where to store the width, in screen coordinates, of the
        /// client area, or `NULL`.
        /// </param>
        /// <param name="height">
        /// Where to store the height, in screen coordinates, of the
        /// client area, or `NULL`.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void GetWindowSize(global::glfw3.GLFWwindow window, ref int width, ref int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __refParamPtr1 = &width)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &height)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GetWindowSize_0(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>
        ///   This function sets the size limits of the client area of the specified
        ///   window.  If the window is full screen, the size limits only take effect
        ///   once it is made windowed.  If the window is not resizable, this function
        ///   does nothing.
        ///   The size limits are applied immediately to a windowed mode window and may
        ///   cause it to be resized.
        ///   The maximum dimensions must be greater than or equal to the minimum
        ///   dimensions and all must be greater than or equal to zero.
        /// </summary>
        /// <param name="window">The window to set limits for.</param>
        /// <param name="minwidth">
        /// The minimum width, in screen coordinates, of the client
        /// area, or `GLFW_DONT_CARE`.
        /// </param>
        /// <param name="minheight">
        /// The minimum height, in screen coordinates, of the
        /// client area, or `GLFW_DONT_CARE`.
        /// </param>
        /// <param name="maxwidth">
        /// The maximum width, in screen coordinates, of the client
        /// area, or `GLFW_DONT_CARE`.
        /// </param>
        /// <param name="maxheight">
        /// The maximum height, in screen coordinates, of the
        /// client area, or `GLFW_DONT_CARE`.
        /// 
        /// Possible errors include
        /// GLFW_INVALID_VALUE and
        /// 
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void SetWindowSizeLimits(global::glfw3.GLFWwindow window, int minwidth, int minheight, int maxwidth, int maxheight)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetWindowSizeLimits_0(__arg0, minwidth, minheight, maxwidth, maxheight);
        }

        /// <summary>
        ///   This function sets the required aspect ratio of the client area of the
        ///   specified window.  If the window is full screen, the aspect ratio only takes
        ///   effect once it is made windowed.  If the window is not resizable, this
        ///   function does nothing.
        ///   The aspect ratio is specified as a numerator and a denominator and both
        ///   values must be greater than zero.  For example, the common 16:9 aspect ratio
        ///   is specified as 16 and 9, respectively.
        ///   If the numerator and denominator is set to `GLFW_DONT_CARE` then the aspect
        ///   ratio limit is disabled.
        ///   The aspect ratio is applied immediately to a windowed mode window and may
        ///   cause it to be resized.
        /// </summary>
        /// <param name="window">The window to set limits for.</param>
        /// <param name="numer">
        /// The numerator of the desired aspect ratio, or
        /// `GLFW_DONT_CARE`.
        /// </param>
        /// <param name="denom">
        /// The denominator of the desired aspect ratio, or
        /// `GLFW_DONT_CARE`.
        /// 
        /// Possible errors include
        /// GLFW_INVALID_VALUE and
        /// 
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void SetWindowAspectRatio(global::glfw3.GLFWwindow window, int numer, int denom)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetWindowAspectRatio_0(__arg0, numer, denom);
        }

        /// <summary>
        ///   This function sets the size, in screen coordinates, of the client area of
        ///   the specified window.
        ///   For full screen windows, this function updates the resolution of its desired
        ///   video mode and switches to the video mode closest to it, without affecting
        ///   the window's context.  As the context is unaffected, the bit depths of the
        ///   framebuffer remain unchanged.
        ///   If you wish to update the refresh rate of the desired video mode in addition
        ///   to its resolution, see 
        ///   The window manager may put limits on what sizes are allowed.  GLFW cannot
        ///   and should not override these limits.
        /// </summary>
        /// <param name="window">The window to resize.</param>
        /// <param name="width">
        /// The desired width, in screen coordinates, of the window
        /// client area.
        /// </param>
        /// <param name="height">
        /// The desired height, in screen coordinates, of the window
        /// client area.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void SetWindowSize(global::glfw3.GLFWwindow window, int width, int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetWindowSize_0(__arg0, width, height);
        }

        /// <summary>
        ///   This function retrieves the size, in pixels, of the framebuffer of the
        ///   specified window.  If you wish to retrieve the size of the window in screen
        ///   coordinates, see 
        ///   Any or all of the size arguments may be `NULL`.  If an error occurs, all
        ///   non-`NULL` size arguments will be set to zero.
        /// </summary>
        /// <param name="window">The window whose framebuffer to query.</param>
        /// <param name="width">
        /// Where to store the width, in pixels, of the framebuffer,
        /// or `NULL`.
        /// </param>
        /// <param name="height">
        /// Where to store the height, in pixels, of the framebuffer,
        /// or `NULL`.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void GetFramebufferSize(global::glfw3.GLFWwindow window, ref int width, ref int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __refParamPtr1 = &width)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &height)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GetFramebufferSize_0(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>
        ///   This function retrieves the size, in screen coordinates, of each edge of the
        ///   frame of the specified window.  This size includes the title bar, if the
        ///   window has one.  The size of the frame may vary depending on the
        ///   [window-related hints](
        ///   Because this function retrieves the size of each window frame edge and not
        ///   the offset along a particular coordinate axis, the retrieved values will
        ///   always be zero or positive.
        ///   Any or all of the size arguments may be `NULL`.  If an error occurs, all
        ///   non-`NULL` size arguments will be set to zero.
        /// </summary>
        /// <param name="window">The window whose frame size to query.</param>
        /// <param name="left">
        /// Where to store the size, in screen coordinates, of the left
        /// edge of the window frame, or `NULL`.
        /// </param>
        /// <param name="top">
        /// Where to store the size, in screen coordinates, of the top
        /// edge of the window frame, or `NULL`.
        /// </param>
        /// <param name="right">
        /// Where to store the size, in screen coordinates, of the
        /// right edge of the window frame, or `NULL`.
        /// </param>
        /// <param name="bottom">
        /// Where to store the size, in screen coordinates, of the
        /// bottom edge of the window frame, or `NULL`.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void GetWindowFrameSize(global::glfw3.GLFWwindow window, ref int left, ref int top, ref int right, ref int bottom)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __refParamPtr1 = &left)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &top)
                {
                    var __arg2 = __refParamPtr2;
                    fixed (int* __refParamPtr3 = &right)
                    {
                        var __arg3 = __refParamPtr3;
                        fixed (int* __refParamPtr4 = &bottom)
                        {
                            var __arg4 = __refParamPtr4;
                            __Internal.GetWindowFrameSize_0(__arg0, __arg1, __arg2, __arg3, __arg4);
                        }
                    }
                }
            }
        }

        /// <summary>
        ///   This function iconifies (minimizes) the specified window if it was
        ///   previously restored.  If the window is already iconified, this function does
        ///   nothing.
        ///   If the specified window is a full screen window, the original monitor
        ///   resolution is restored until the window is restored.
        /// </summary>
        /// <param name="window">
        /// The window to iconify.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void IconifyWindow(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.IconifyWindow_0(__arg0);
        }

        /// <summary>
        ///   This function restores the specified window if it was previously iconified
        ///   (minimized) or maximized.  If the window is already restored, this function
        ///   does nothing.
        ///   If the specified window is a full screen window, the resolution chosen for
        ///   the window is restored on the selected monitor.
        /// </summary>
        /// <param name="window">
        /// The window to restore.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void RestoreWindow(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.RestoreWindow_0(__arg0);
        }

        /// <summary>
        ///   This function maximizes the specified window if it was previously not
        ///   maximized.  If the window is already maximized, this function does nothing.
        ///   If the specified window is a full screen window, this function does nothing.
        /// </summary>
        /// <param name="window">
        /// The window to maximize.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// </param>
        public static void MaximizeWindow(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.MaximizeWindow_0(__arg0);
        }

        /// <summary>
        ///   This function makes the specified window visible if it was previously
        ///   hidden.  If the window is already visible or is in full screen mode, this
        ///   function does nothing.
        /// </summary>
        /// <param name="window">
        /// The window to make visible.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void ShowWindow(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.ShowWindow_0(__arg0);
        }

        /// <summary>
        ///   This function hides the specified window if it was previously visible.  If
        ///   the window is already hidden or is in full screen mode, this function does
        ///   nothing.
        /// </summary>
        /// <param name="window">
        /// The window to hide.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void HideWindow(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.HideWindow_0(__arg0);
        }

        /// <summary>
        ///   This function brings the specified window to front and sets input focus.
        ///   The window should already be visible and not iconified.
        ///   By default, both windowed and full screen mode windows are focused when
        ///   initially created.  Set the [GLFW_FOCUSED](
        ///   this behavior.
        ///   __Do not use this function__ to steal focus from other applications unless
        ///   you are certain that is what the user wants.  Focus stealing can be
        ///   extremely disruptive.
        /// </summary>
        /// <param name="window">
        /// The window to give input focus.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void FocusWindow(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.FocusWindow_0(__arg0);
        }

        /// <summary>
        ///   This function returns the handle of the monitor that the specified window is
        ///   in full screen on.
        /// </summary>
        /// <param name="window">The window to query.</param>
        /// <returns>
        /// The monitor, or `NULL` if the window is in windowed mode or an
        /// [error](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWmonitor GetWindowMonitor(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowMonitor_0(__arg0);
            global::glfw3.GLFWmonitor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.GLFWmonitor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.GLFWmonitor) global::glfw3.GLFWmonitor.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.GLFWmonitor.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        ///   This function sets the monitor that the window uses for full screen mode or,
        ///   if the monitor is `NULL`, makes it windowed mode.
        ///   When setting a monitor, this function updates the width, height and refresh
        ///   rate of the desired video mode and switches to the video mode closest to it.
        ///   The window position is ignored when setting a monitor.
        ///   When the monitor is `NULL`, the position, width and height are used to
        ///   place the window client area.  The refresh rate is ignored when no monitor
        ///   is specified.
        ///   If you only wish to update the resolution of a full screen window or the
        ///   size of a windowed mode window, see 
        ///   When a window transitions from full screen to windowed mode, this function
        ///   restores any previous window settings such as whether it is decorated,
        ///   floating, resizable, has size or aspect ratio limits, etc..
        /// </summary>
        /// <param name="window">The window whose monitor, size or video mode to set.</param>
        /// <param name="monitor">The desired monitor, or `NULL` to set windowed mode.</param>
        /// <param name="xpos">
        /// The desired x-coordinate of the upper-left corner of the
        /// client area.
        /// </param>
        /// <param name="ypos">
        /// The desired y-coordinate of the upper-left corner of the
        /// client area.
        /// </param>
        /// <param name="width">
        /// The desired with, in screen coordinates, of the client area
        /// or video mode.
        /// </param>
        /// <param name="height">
        /// The desired height, in screen coordinates, of the client
        /// area or video mode.
        /// </param>
        /// <param name="refreshRate">
        /// The desired refresh rate, in Hz, of the video mode,
        /// or `GLFW_DONT_CARE`.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void SetWindowMonitor(global::glfw3.GLFWwindow window, global::glfw3.GLFWmonitor monitor, int xpos, int ypos, int width, int height, int refreshRate)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            __Internal.SetWindowMonitor_0(__arg0, __arg1, xpos, ypos, width, height, refreshRate);
        }

        /// <summary>
        ///   This function returns the value of an attribute of the specified window or
        ///   its OpenGL or OpenGL ES context.
        /// </summary>
        /// <param name="window">The window to query.</param>
        /// <param name="attrib">
        /// The [window attribute](
        /// return.
        /// </param>
        /// <returns>
        /// The value of the attribute, or zero if an
        /// [error](
        /// 
        /// Possible errors include
        /// GLFW_INVALID_ENUM and
        /// 
        /// window_attribs_fb for more information.
        /// 
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static int GetWindowAttrib(global::glfw3.GLFWwindow window, int attrib)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowAttrib_0(__arg0, attrib);
            return __ret;
        }

        /// <summary>
        ///   This function sets the user-defined pointer of the specified window.  The
        ///   current value is retained until the window is destroyed.  The initial value
        ///   is `NULL`.
        /// </summary>
        /// <param name="window">The window whose pointer to set.</param>
        /// <param name="pointer">
        /// The new value.
        /// 
        /// Possible errors include
        /// 
        /// _safety This function may be called from any thread.  Access is not
        /// synchronized.
        /// </param>
        public static void SetWindowUserPointer(global::glfw3.GLFWwindow window, global::System.IntPtr pointer)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetWindowUserPointer_0(__arg0, pointer);
        }

        /// <summary>
        ///   This function returns the current value of the user-defined pointer of the
        ///   specified window.  The initial value is `NULL`.
        /// </summary>
        /// <param name="window">
        /// The window whose pointer to return.
        /// 
        /// Possible errors include
        /// 
        /// _safety This function may be called from any thread.  Access is not
        /// synchronized.
        /// </param>
        public static global::System.IntPtr GetWindowUserPointer(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowUserPointer_0(__arg0);
            return __ret;
        }

        /// <summary>
        ///   This function sets the position callback of the specified window, which is
        ///   called when the window is moved.  The callback is provided with the screen
        ///   position of the upper-left corner of the client area of the window.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// The new callback, or `NULL` to remove the currently set
        /// callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set or the
        /// library had not been [initialized](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWwindowposfun SetWindowPosCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWwindowposfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetWindowPosCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWwindowposfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWwindowposfun));
        }

        /// <summary>
        ///   This function sets the size callback of the specified window, which is
        ///   called when the window is resized.  The callback is provided with the size,
        ///   in screen coordinates, of the client area of the window.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// The new callback, or `NULL` to remove the currently set
        /// callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set or the
        /// library had not been [initialized](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWwindowsizefun SetWindowSizeCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWwindowsizefun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetWindowSizeCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWwindowsizefun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWwindowsizefun));
        }

        /// <summary>
        ///   This function sets the close callback of the specified window, which is
        ///   called when the user attempts to close the window, for example by clicking
        ///   the close widget in the title bar.
        ///   The close flag is set before this callback is called, but you can modify it
        ///   at any time with 
        ///   The close callback is not triggered by 
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// The new callback, or `NULL` to remove the currently set
        /// callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set or the
        /// library had not been [initialized](
        /// 
        /// Possible errors include
        /// 
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWwindowclosefun SetWindowCloseCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWwindowclosefun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetWindowCloseCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWwindowclosefun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWwindowclosefun));
        }

        /// <summary>
        ///   This function sets the refresh callback of the specified window, which is
        ///   called when the client area of the window needs to be redrawn, for example
        ///   if the window has been exposed after having been covered by another window.
        ///   On compositing window systems such as Aero, Compiz or Aqua, where the window
        ///   contents are saved off-screen, this callback may be called only very
        ///   infrequently or never at all.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// The new callback, or `NULL` to remove the currently set
        /// callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set or the
        /// library had not been [initialized](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWwindowrefreshfun SetWindowRefreshCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWwindowrefreshfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetWindowRefreshCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWwindowrefreshfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWwindowrefreshfun));
        }

        /// <summary>
        ///   This function sets the focus callback of the specified window, which is
        ///   called when the window gains or loses input focus.
        ///   After the focus callback is called for a window that lost input focus,
        ///   synthetic key and mouse button release events will be generated for all such
        ///   that had been pressed.  For more information, see 
        ///   and 
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// The new callback, or `NULL` to remove the currently set
        /// callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set or the
        /// library had not been [initialized](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWwindowfocusfun SetWindowFocusCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWwindowfocusfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetWindowFocusCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWwindowfocusfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWwindowfocusfun));
        }

        /// <summary>
        ///   This function sets the iconification callback of the specified window, which
        ///   is called when the window is iconified or restored.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// The new callback, or `NULL` to remove the currently set
        /// callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set or the
        /// library had not been [initialized](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWwindowiconifyfun SetWindowIconifyCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWwindowiconifyfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetWindowIconifyCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWwindowiconifyfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWwindowiconifyfun));
        }

        /// <summary>
        ///   This function sets the framebuffer resize callback of the specified window,
        ///   which is called when the framebuffer of the specified window is resized.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// The new callback, or `NULL` to remove the currently set
        /// callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set or the
        /// library had not been [initialized](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWframebuffersizefun SetFramebufferSizeCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWframebuffersizefun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetFramebufferSizeCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWframebuffersizefun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWframebuffersizefun));
        }

        /// <summary>
        ///   This function processes only those events that are already in the event
        ///   queue and then returns immediately.  Processing events will cause the window
        ///   and input callbacks associated with those events to be called.
        ///   On some platforms, a window move, resize or menu operation will cause event
        ///   processing to block.  This is due to how event processing is designed on
        ///   those platforms.  You can use the
        ///   [window refresh callback](
        ///   your window when necessary during such operations.
        ///   On some platforms, certain events are sent directly to the application
        ///   without going through the event queue, causing callbacks to be called
        ///   outside of a call to one of the event processing functions.
        ///   Event processing is not required for joystick input to work.
        ///   
        /// Possible errors include 
        ///   GLFW_PLATFORM_ERROR.
        ///   
        /// This function must not be called from a callback.
        ///   
        /// _safety This function must only be called from the main thread.
        /// </summary>
        public static void PollEvents()
        {
            __Internal.PollEvents_0();
        }

        /// <summary>
        ///   This function puts the calling thread to sleep until at least one event is
        ///   available in the event queue.  Once one or more events are available,
        ///   it behaves exactly like 
        ///   are processed and the function then returns immediately.  Processing events
        ///   will cause the window and input callbacks associated with those events to be
        ///   called.
        ///   Since not all events are associated with callbacks, this function may return
        ///   without a callback having been called even if you are monitoring all
        ///   callbacks.
        ///   On some platforms, a window move, resize or menu operation will cause event
        ///   processing to block.  This is due to how event processing is designed on
        ///   those platforms.  You can use the
        ///   [window refresh callback](
        ///   your window when necessary during such operations.
        ///   On some platforms, certain callbacks may be called outside of a call to one
        ///   of the event processing functions.
        ///   If no windows exist, this function returns immediately.  For synchronization
        ///   of threads in applications that do not create windows, use your threading
        ///   library of choice.
        ///   Event processing is not required for joystick input to work.
        ///   
        /// Possible errors include 
        ///   GLFW_PLATFORM_ERROR.
        ///   
        /// This function must not be called from a callback.
        ///   
        /// _safety This function must only be called from the main thread.
        /// </summary>
        public static void WaitEvents()
        {
            __Internal.WaitEvents_0();
        }

        /// <summary>
        ///   This function puts the calling thread to sleep until at least one event is
        ///   available in the event queue, or until the specified timeout is reached.  If
        ///   one or more events are available, it behaves exactly like 
        ///   glfwPollEvents, i.e. the events in the queue are processed and the function
        ///   then returns immediately.  Processing events will cause the window and input
        ///   callbacks associated with those events to be called.
        ///   The timeout value must be a positive finite number.
        ///   Since not all events are associated with callbacks, this function may return
        ///   without a callback having been called even if you are monitoring all
        ///   callbacks.
        ///   On some platforms, a window move, resize or menu operation will cause event
        ///   processing to block.  This is due to how event processing is designed on
        ///   those platforms.  You can use the
        ///   [window refresh callback](
        ///   your window when necessary during such operations.
        ///   On some platforms, certain callbacks may be called outside of a call to one
        ///   of the event processing functions.
        ///   If no windows exist, this function returns immediately.  For synchronization
        ///   of threads in applications that do not create windows, use your threading
        ///   library of choice.
        ///   Event processing is not required for joystick input to work.
        /// </summary>
        /// <param name="timeout">
        /// The maximum amount of time, in seconds, to wait.
        /// 
        /// This function must not be called from a callback.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void WaitEventsTimeout(double timeout)
        {
            __Internal.WaitEventsTimeout_0(timeout);
        }

        /// <summary>
        ///   This function posts an empty event from the current thread to the event
        ///   queue, causing 
        ///   If no windows exist, this function returns immediately.  For synchronization
        ///   of threads in applications that do not create windows, use your threading
        ///   library of choice.
        ///   
        /// Possible errors include 
        ///   GLFW_PLATFORM_ERROR.
        ///   
        /// _safety This function may be called from any thread.
        /// </summary>
        public static void PostEmptyEvent()
        {
            __Internal.PostEmptyEvent_0();
        }

        /// <summary>
        ///   This function returns the value of an input option for the specified window.
        ///   The mode must be one of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or
        ///   `GLFW_STICKY_MOUSE_BUTTONS`.
        /// </summary>
        /// <param name="window">The window to query.</param>
        /// <param name="mode">
        /// One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or
        /// `GLFW_STICKY_MOUSE_BUTTONS`.
        /// 
        /// Possible errors include
        /// GLFW_INVALID_ENUM.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static int GetInputMode(global::glfw3.GLFWwindow window, int mode)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetInputMode_0(__arg0, mode);
            return __ret;
        }

        /// <summary>
        ///   This function sets an input mode option for the specified window.  The mode
        ///   must be one of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or
        ///   `GLFW_STICKY_MOUSE_BUTTONS`.
        ///   If the mode is `GLFW_CURSOR`, the value must be one of the following cursor
        ///   modes:
        ///   - `GLFW_CURSOR_NORMAL` makes the cursor visible and behaving normally.
        ///   - `GLFW_CURSOR_HIDDEN` makes the cursor invisible when it is over the client
        ///     area of the window but does not restrict the cursor from leaving.
        ///   - `GLFW_CURSOR_DISABLED` hides and grabs the cursor, providing virtual
        ///     and unlimited cursor movement.  This is useful for implementing for
        ///     example 3D camera controls.
        ///   If the mode is `GLFW_STICKY_KEYS`, the value must be either `GLFW_TRUE` to
        ///   enable sticky keys, or `GLFW_FALSE` to disable it.  If sticky keys are
        ///   enabled, a key press will ensure that 
        ///   the next time it is called even if the key had been released before the
        ///   call.  This is useful when you are only interested in whether keys have been
        ///   pressed but not when or in which order.
        ///   If the mode is `GLFW_STICKY_MOUSE_BUTTONS`, the value must be either
        ///   `GLFW_TRUE` to enable sticky mouse buttons, or `GLFW_FALSE` to disable it.
        ///   If sticky mouse buttons are enabled, a mouse button press will ensure that
        ///   
        ///   if the mouse button had been released before the call.  This is useful when
        ///   you are only interested in whether mouse buttons have been pressed but not
        ///   when or in which order.
        /// </summary>
        /// <param name="window">The window whose input mode to set.</param>
        /// <param name="mode">
        /// One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or
        /// `GLFW_STICKY_MOUSE_BUTTONS`.
        /// </param>
        /// <param name="value">
        /// The new value of the specified input mode.
        /// 
        /// Possible errors include
        /// GLFW_INVALID_ENUM and
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void SetInputMode(global::glfw3.GLFWwindow window, int mode, int value)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetInputMode_0(__arg0, mode, value);
        }

        /// <summary>
        ///   This function returns the localized name of the specified printable key.
        ///   This is intended for displaying key bindings to the user.
        ///   If the key is `GLFW_KEY_UNKNOWN`, the scancode is used instead, otherwise
        ///   the scancode is ignored.  If a non-printable key or (if the key is
        ///   `GLFW_KEY_UNKNOWN`) a scancode that maps to a non-printable key is
        ///   specified, this function returns `NULL`.          
        ///   This behavior allows you to pass in the arguments passed to the
        ///   [key callback](
        ///   The printable keys are:
        ///   - `GLFW_KEY_APOSTROPHE`
        ///   - `GLFW_KEY_COMMA`
        ///   - `GLFW_KEY_MINUS`
        ///   - `GLFW_KEY_PERIOD`
        ///   - `GLFW_KEY_SLASH`
        ///   - `GLFW_KEY_SEMICOLON`
        ///   - `GLFW_KEY_EQUAL`
        ///   - `GLFW_KEY_LEFT_BRACKET`
        ///   - `GLFW_KEY_RIGHT_BRACKET`
        ///   - `GLFW_KEY_BACKSLASH`
        ///   - `GLFW_KEY_WORLD_1`
        ///   - `GLFW_KEY_WORLD_2`
        ///   - `GLFW_KEY_0` to `GLFW_KEY_9`
        ///   - `GLFW_KEY_A` to `GLFW_KEY_Z`
        ///   - `GLFW_KEY_KP_0` to `GLFW_KEY_KP_9`
        ///   - `GLFW_KEY_KP_DECIMAL`
        ///   - `GLFW_KEY_KP_DIVIDE`
        ///   - `GLFW_KEY_KP_MULTIPLY`
        ///   - `GLFW_KEY_KP_SUBTRACT`
        ///   - `GLFW_KEY_KP_ADD`
        ///   - `GLFW_KEY_KP_EQUAL`
        /// </summary>
        /// <param name="key">The key to query, or `GLFW_KEY_UNKNOWN`.</param>
        /// <param name="scancode">The scancode of the key to query.</param>
        /// <returns>
        /// The localized name of the key, or `NULL`.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _lifetime The returned string is allocated and freed by GLFW.  You
        /// should not free it yourself.  It is valid until the next call to
        /// glfwGetKeyName, or until the library is terminated.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static string GetKeyName(int key, int scancode)
        {
            var __ret = __Internal.GetKeyName_0(key, scancode);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        ///   This function returns the last state reported for the specified key to the
        ///   specified window.  The returned state is one of `GLFW_PRESS` or
        ///   `GLFW_RELEASE`.  The higher-level action `GLFW_REPEAT` is only reported to
        ///   the key callback.
        ///   If the `GLFW_STICKY_KEYS` input mode is enabled, this function returns
        ///   `GLFW_PRESS` the first time you call it for a key that was pressed, even if
        ///   that key has already been released.
        ///   The key functions deal with physical keys, with [key tokens](
        ///   named after their use on the standard US keyboard layout.  If you want to
        ///   input text, use the Unicode character callback instead.
        ///   The [modifier key bit masks](
        ///   used with this function.
        ///   __Do not use this function__ to implement [text input](
        /// </summary>
        /// <param name="window">The desired window.</param>
        /// <param name="key">
        /// The desired [keyboard key](
        /// not a valid key for this function.
        /// </param>
        /// <returns>
        /// One of `GLFW_PRESS` or `GLFW_RELEASE`.
        /// 
        /// Possible errors include
        /// GLFW_INVALID_ENUM.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static int GetKey(global::glfw3.GLFWwindow window, int key)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetKey_0(__arg0, key);
            return __ret;
        }

        /// <summary>
        ///   This function returns the last state reported for the specified mouse button
        ///   to the specified window.  The returned state is one of `GLFW_PRESS` or
        ///   `GLFW_RELEASE`.
        ///   If the `GLFW_STICKY_MOUSE_BUTTONS` input mode is enabled, this function
        ///   `GLFW_PRESS` the first time you call it for a mouse button that was pressed,
        ///   even if that mouse button has already been released.
        /// </summary>
        /// <param name="window">The desired window.</param>
        /// <param name="button">The desired [mouse button](</param>
        /// <returns>
        /// One of `GLFW_PRESS` or `GLFW_RELEASE`.
        /// 
        /// Possible errors include
        /// GLFW_INVALID_ENUM.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static int GetMouseButton(global::glfw3.GLFWwindow window, int button)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetMouseButton_0(__arg0, button);
            return __ret;
        }

        /// <summary>
        ///   This function returns the position of the cursor, in screen coordinates,
        ///   relative to the upper-left corner of the client area of the specified
        ///   window.
        ///   If the cursor is disabled (with `GLFW_CURSOR_DISABLED`) then the cursor
        ///   position is unbounded and limited only by the minimum and maximum values of
        ///   a `double`.
        ///   The coordinate can be converted to their integer equivalents with the
        ///   `floor` function.  Casting directly to an integer type works for positive
        ///   coordinates, but fails for negative ones.
        ///   Any or all of the position arguments may be `NULL`.  If an error occurs, all
        ///   non-`NULL` position arguments will be set to zero.
        /// </summary>
        /// <param name="window">The desired window.</param>
        /// <param name="xpos">
        /// Where to store the cursor x-coordinate, relative to the
        /// left edge of the client area, or `NULL`.
        /// </param>
        /// <param name="ypos">
        /// Where to store the cursor y-coordinate, relative to the to
        /// top edge of the client area, or `NULL`.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void GetCursorPos(global::glfw3.GLFWwindow window, ref double xpos, ref double ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (double* __refParamPtr1 = &xpos)
            {
                var __arg1 = __refParamPtr1;
                fixed (double* __refParamPtr2 = &ypos)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GetCursorPos_0(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>
        ///   This function sets the position, in screen coordinates, of the cursor
        ///   relative to the upper-left corner of the client area of the specified
        ///   window.  The window must have input focus.  If the window does not have
        ///   input focus when this function is called, it fails silently.
        ///   __Do not use this function__ to implement things like camera controls.  GLFW
        ///   already provides the `GLFW_CURSOR_DISABLED` cursor mode that hides the
        ///   cursor, transparently re-centers it and provides unconstrained cursor
        ///   motion.  See 
        ///   If the cursor mode is `GLFW_CURSOR_DISABLED` then the cursor position is
        ///   unconstrained and limited only by the minimum and maximum values of
        ///   a `double`.
        /// </summary>
        /// <param name="window">The desired window.</param>
        /// <param name="xpos">
        /// The desired x-coordinate, relative to the left edge of the
        /// client area.
        /// </param>
        /// <param name="ypos">
        /// The desired y-coordinate, relative to the top edge of the
        /// client area.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void SetCursorPos(global::glfw3.GLFWwindow window, double xpos, double ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetCursorPos_0(__arg0, xpos, ypos);
        }

        /// <summary>
        ///   Creates a new custom cursor image that can be set for a window with 
        ///   glfwSetCursor.  The cursor can be destroyed with 
        ///   Any remaining cursors are destroyed by 
        ///   The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight
        ///   bits per channel.  They are arranged canonically as packed sequential rows,
        ///   starting from the top-left corner.
        ///   The cursor hotspot is specified in pixels, relative to the upper-left corner
        ///   of the cursor image.  Like all other coordinate systems in GLFW, the X-axis
        ///   points to the right and the Y-axis points down.
        /// </summary>
        /// <param name="image">The desired cursor image.</param>
        /// <param name="xhot">The desired x-coordinate, in pixels, of the cursor hotspot.</param>
        /// <param name="yhot">The desired y-coordinate, in pixels, of the cursor hotspot.</param>
        /// <returns>
        /// The handle of the created cursor, or `NULL` if an
        /// [error](
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _lifetime The specified image data is copied before this function
        /// returns.
        /// 
        /// This function must not be called from a callback.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWcursor CreateCursor(global::glfw3.GLFWimage image, int xhot, int yhot)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            var __ret = __Internal.CreateCursor_0(__arg0, xhot, yhot);
            global::glfw3.GLFWcursor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.GLFWcursor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.GLFWcursor) global::glfw3.GLFWcursor.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.GLFWcursor.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        ///   Returns a cursor with a [standard shape](
        ///   a window with 
        /// </summary>
        /// <param name="shape">One of the [standard shapes](</param>
        /// <returns>
        /// A new cursor ready to use or `NULL` if an
        /// [error](
        /// 
        /// Possible errors include
        /// GLFW_INVALID_ENUM and
        /// 
        /// This function must not be called from a callback.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWcursor CreateStandardCursor(int shape)
        {
            var __ret = __Internal.CreateStandardCursor_0(shape);
            global::glfw3.GLFWcursor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.GLFWcursor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.GLFWcursor) global::glfw3.GLFWcursor.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.GLFWcursor.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        ///   This function destroys a cursor previously created with 
        ///   glfwCreateCursor.  Any remaining cursors will be destroyed by 
        ///   glfwTerminate.
        /// </summary>
        /// <param name="cursor">
        /// The cursor object to destroy.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// This function must not be called from a callback.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void DestroyCursor(global::glfw3.GLFWcursor cursor)
        {
            var __arg0 = ReferenceEquals(cursor, null) ? global::System.IntPtr.Zero : cursor.__Instance;
            __Internal.DestroyCursor_0(__arg0);
        }

        /// <summary>
        ///   This function sets the cursor image to be used when the cursor is over the
        ///   client area of the specified window.  The set cursor will only be visible
        ///   when the [cursor mode](
        ///   `GLFW_CURSOR_NORMAL`.
        ///   On some platforms, the set cursor may not be visible unless the window also
        ///   has input focus.
        /// </summary>
        /// <param name="window">The window to set the cursor for.</param>
        /// <param name="cursor">
        /// The cursor to set, or `NULL` to switch back to the default
        /// arrow cursor.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void SetCursor(global::glfw3.GLFWwindow window, global::glfw3.GLFWcursor cursor)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = ReferenceEquals(cursor, null) ? global::System.IntPtr.Zero : cursor.__Instance;
            __Internal.SetCursor_0(__arg0, __arg1);
        }

        /// <summary>
        ///   This function sets the key callback of the specified window, which is called
        ///   when a key is pressed, repeated or released.
        ///   The key functions deal with physical keys, with layout independent
        ///   [key tokens](
        ///   layout.  If you want to input text, use the
        ///   [character callback](
        ///   When a window loses input focus, it will generate synthetic key release
        ///   events for all pressed keys.  You can tell these events from user-generated
        ///   events by the fact that the synthetic ones are generated after the focus
        ///   loss event has been processed, i.e. after the
        ///   [window focus callback](
        ///   The scancode of a key is specific to that platform or sometimes even to that
        ///   machine.  Scancodes are intended to allow users to bind keys that don't have
        ///   a GLFW key token.  Such keys have `key` set to `GLFW_KEY_UNKNOWN`, their
        ///   state is not saved and so it cannot be queried with 
        ///   Sometimes GLFW needs to generate synthetic key events, in which case the
        ///   scancode may be zero.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// The new key callback, or `NULL` to remove the currently
        /// set callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set or the
        /// library had not been [initialized](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWkeyfun SetKeyCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWkeyfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetKeyCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWkeyfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWkeyfun));
        }

        /// <summary>
        ///   This function sets the character callback of the specified window, which is
        ///   called when a Unicode character is input.
        ///   The character callback is intended for Unicode text input.  As it deals with
        ///   characters, it is keyboard layout dependent, whereas the
        ///   [key callback](
        ///   to physical keys, as a key may produce zero, one or more characters.  If you
        ///   want to know whether a specific physical key was pressed or released, see
        ///   the key callback instead.
        ///   The character callback behaves as system text input normally does and will
        ///   not be called if modifier keys are held down that would prevent normal text
        ///   input on that platform, for example a Super (Command) key on OS X or Alt key
        ///   on Windows.  There is a
        ///   [character with modifiers callback](
        ///   receives these events.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// The new callback, or `NULL` to remove the currently set
        /// callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set or the
        /// library had not been [initialized](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWcharfun SetCharCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWcharfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetCharCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWcharfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWcharfun));
        }

        /// <summary>
        ///   This function sets the character with modifiers callback of the specified
        ///   window, which is called when a Unicode character is input regardless of what
        ///   modifier keys are used.
        ///   The character with modifiers callback is intended for implementing custom
        ///   Unicode character input.  For regular Unicode text input, see the
        ///   [character callback](
        ///   callback, the character with modifiers callback deals with characters and is
        ///   keyboard layout dependent.  Characters do not map 1:1 to physical keys, as
        ///   a key may produce zero, one or more characters.  If you want to know whether
        ///   a specific physical key was pressed or released, see the
        ///   [key callback](
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// The new callback, or `NULL` to remove the currently set
        /// callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set or an
        /// [error](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWcharmodsfun SetCharModsCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWcharmodsfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetCharModsCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWcharmodsfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWcharmodsfun));
        }

        /// <summary>
        ///   This function sets the mouse button callback of the specified window, which
        ///   is called when a mouse button is pressed or released.
        ///   When a window loses input focus, it will generate synthetic mouse button
        ///   release events for all pressed mouse buttons.  You can tell these events
        ///   from user-generated events by the fact that the synthetic ones are generated
        ///   after the focus loss event has been processed, i.e. after the
        ///   [window focus callback](
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// The new callback, or `NULL` to remove the currently set
        /// callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set or the
        /// library had not been [initialized](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWmousebuttonfun SetMouseButtonCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWmousebuttonfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetMouseButtonCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWmousebuttonfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWmousebuttonfun));
        }

        /// <summary>
        ///   This function sets the cursor position callback of the specified window,
        ///   which is called when the cursor is moved.  The callback is provided with the
        ///   position, in screen coordinates, relative to the upper-left corner of the
        ///   client area of the window.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// The new callback, or `NULL` to remove the currently set
        /// callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set or the
        /// library had not been [initialized](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWcursorposfun SetCursorPosCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWcursorposfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetCursorPosCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWcursorposfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWcursorposfun));
        }

        /// <summary>
        ///   This function sets the cursor boundary crossing callback of the specified
        ///   window, which is called when the cursor enters or leaves the client area of
        ///   the window.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// The new callback, or `NULL` to remove the currently set
        /// callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set or the
        /// library had not been [initialized](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWcursorenterfun SetCursorEnterCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWcursorenterfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetCursorEnterCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWcursorenterfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWcursorenterfun));
        }

        /// <summary>
        ///   This function sets the scroll callback of the specified window, which is
        ///   called when a scrolling device is used, such as a mouse wheel or scrolling
        ///   area of a touchpad.
        ///   The scroll callback receives all scrolling input, like that from a mouse
        ///   wheel or a touchpad scrolling area.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// The new scroll callback, or `NULL` to remove the currently
        /// set callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set or the
        /// library had not been [initialized](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWscrollfun SetScrollCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWscrollfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetScrollCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWscrollfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWscrollfun));
        }

        /// <summary>
        ///   This function sets the file drop callback of the specified window, which is
        ///   called when one or more dragged files are dropped on the window.
        ///   Because the path array and its strings may have been generated specifically
        ///   for that event, they are not guaranteed to be valid after the callback has
        ///   returned.  If you wish to use them after the callback returns, you need to
        ///   make a deep copy.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// The new file drop callback, or `NULL` to remove the
        /// currently set callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set or the
        /// library had not been [initialized](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWdropfun SetDropCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWdropfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetDropCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWdropfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWdropfun));
        }

        /// <summary>  This function returns whether the specified joystick is present.</summary>
        /// <param name="joy">The [joystick](</param>
        /// <returns>
        /// `GLFW_TRUE` if the joystick is present, or `GLFW_FALSE` otherwise.
        /// 
        /// Possible errors include
        /// GLFW_INVALID_ENUM and
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static int JoystickPresent(int joy)
        {
            var __ret = __Internal.JoystickPresent_0(joy);
            return __ret;
        }

        /// <summary>
        ///   This function returns the values of all axes of the specified joystick.
        ///   Each element in the array is a value between -1.0 and 1.0.
        ///   Querying a joystick slot with no device present is not an error, but will
        ///   cause this function to return `NULL`.  Call 
        ///   check device presence.
        /// </summary>
        /// <param name="joy">The [joystick](</param>
        /// <param name="count">
        /// Where to store the number of axis values in the returned
        /// array.  This is set to zero if the joystick is not present or an error
        /// occurred.
        /// </param>
        /// <returns>
        /// An array of axis values, or `NULL` if the joystick is not present or
        /// an [error](
        /// 
        /// Possible errors include
        /// GLFW_INVALID_ENUM and
        /// 
        /// _lifetime The returned array is allocated and freed by GLFW.  You
        /// should not free it yourself.  It is valid until the specified joystick is
        /// disconnected, this function is called again for that joystick or the library
        /// is terminated.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static float* GetJoystickAxes(int joy, ref int count)
        {
            fixed (int* __refParamPtr1 = &count)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.GetJoystickAxes_0(joy, __arg1);
                return __ret;
            }
        }

        /// <summary>
        ///   This function returns the state of all buttons of the specified joystick.
        ///   Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`.
        ///   Querying a joystick slot with no device present is not an error, but will
        ///   cause this function to return `NULL`.  Call 
        ///   check device presence.
        /// </summary>
        /// <param name="joy">The [joystick](</param>
        /// <param name="count">
        /// Where to store the number of button states in the returned
        /// array.  This is set to zero if the joystick is not present or an error
        /// occurred.
        /// </param>
        /// <returns>
        /// An array of button states, or `NULL` if the joystick is not present
        /// or an [error](
        /// 
        /// Possible errors include
        /// GLFW_INVALID_ENUM and
        /// 
        /// _lifetime The returned array is allocated and freed by GLFW.  You
        /// should not free it yourself.  It is valid until the specified joystick is
        /// disconnected, this function is called again for that joystick or the library
        /// is terminated.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static byte* GetJoystickButtons(int joy, ref int count)
        {
            fixed (int* __refParamPtr1 = &count)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.GetJoystickButtons_0(joy, __arg1);
                return __ret;
            }
        }

        /// <summary>
        ///   This function returns the name, encoded as UTF-8, of the specified joystick.
        ///   The returned string is allocated and freed by GLFW.  You should not free it
        ///   yourself.
        ///   Querying a joystick slot with no device present is not an error, but will
        ///   cause this function to return `NULL`.  Call 
        ///   check device presence.
        /// </summary>
        /// <param name="joy">The [joystick](</param>
        /// <returns>
        /// The UTF-8 encoded name of the joystick, or `NULL` if the joystick
        /// is not present or an [error](
        /// 
        /// Possible errors include
        /// GLFW_INVALID_ENUM and
        /// 
        /// _lifetime The returned string is allocated and freed by GLFW.  You
        /// should not free it yourself.  It is valid until the specified joystick is
        /// disconnected, this function is called again for that joystick or the library
        /// is terminated.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static string GetJoystickName(int joy)
        {
            var __ret = __Internal.GetJoystickName_0(joy);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        ///   This function sets the joystick configuration callback, or removes the
        ///   currently set callback.  This is called when a joystick is connected to or
        ///   disconnected from the system.
        /// </summary>
        /// <param name="cbfun">
        /// The new callback, or `NULL` to remove the currently set
        /// callback.
        /// </param>
        /// <returns>
        /// The previously set callback, or `NULL` if no callback was set or the
        /// library had not been [initialized](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static global::glfw3.GLFWjoystickfun SetJoystickCallback(global::glfw3.GLFWjoystickfun cbfun)
        {
            var __arg0 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.SetJoystickCallback_0(__arg0);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWjoystickfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWjoystickfun));
        }

        /// <summary>
        ///   This function sets the system clipboard to the specified, UTF-8 encoded
        ///   string.
        /// </summary>
        /// <param name="window">The window that will own the clipboard contents.</param>
        /// <param name="string">
        /// A UTF-8 encoded string.
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _lifetime The specified string is copied before this function
        /// returns.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </param>
        public static void SetClipboardString(global::glfw3.GLFWwindow window, string @string)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetClipboardString_0(__arg0, @string);
        }

        /// <summary>
        ///   This function returns the contents of the system clipboard, if it contains
        ///   or is convertible to a UTF-8 encoded string.  If the clipboard is empty or
        ///   if its contents cannot be converted, `NULL` is returned and a 
        ///   GLFW_FORMAT_UNAVAILABLE error is generated.
        /// </summary>
        /// <param name="window">The window that will request the clipboard contents.</param>
        /// <returns>
        /// The contents of the clipboard as a UTF-8 encoded string, or `NULL`
        /// if an [error](
        /// 
        /// Possible errors include
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _lifetime The returned string is allocated and freed by GLFW.  You
        /// should not free it yourself.  It is valid until the next call to
        /// glfwGetClipboardString or
        /// is terminated.
        /// 
        /// _safety This function must only be called from the main thread.
        /// </returns>
        public static string GetClipboardString(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetClipboardString_0(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        ///   This function returns the value of the GLFW timer.  Unless the timer has
        ///   been set using 
        ///   was initialized.
        ///   The resolution of the timer is system dependent, but is usually on the order
        ///   of a few micro- or nanoseconds.  It uses the highest-resolution monotonic
        ///   time source on each supported platform.
        /// </summary>
        /// <returns>
        /// The current value, in seconds, or zero if an
        /// [error](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function may be called from any thread.  Reading and
        /// writing of the internal timer offset is not atomic, so it needs to be
        /// externally synchronized with calls to
        /// </returns>
        public static double GetTime()
        {
            var __ret = __Internal.GetTime_0();
            return __ret;
        }

        /// <summary>
        ///   This function sets the value of the GLFW timer.  It then continues to count
        ///   up from that value.  The value must be a positive finite number less than
        ///   or equal to 18446744073.0, which is approximately 584.5 years.
        /// </summary>
        /// <param name="time">
        /// The new value, in seconds.
        /// 
        /// Possible errors include
        /// GLFW_INVALID_VALUE.
        /// 
        /// 
        /// _safety This function may be called from any thread.  Reading and
        /// writing of the internal timer offset is not atomic, so it needs to be
        /// externally synchronized with calls to
        /// </param>
        public static void SetTime(double time)
        {
            __Internal.SetTime_0(time);
        }

        /// <summary>
        ///   This function returns the current value of the raw timer, measured in
        ///   1
        /// &#160;
        /// /
        /// &#160;
        /// frequency seconds.  To get the frequency, call 
        ///   glfwGetTimerFrequency.
        /// </summary>
        /// <returns>
        /// The value of the timer, or zero if an
        /// [error](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function may be called from any thread.
        /// </returns>
        public static ulong GetTimerValue()
        {
            var __ret = __Internal.GetTimerValue_0();
            return __ret;
        }

        /// <summary>  This function returns the frequency, in Hz, of the raw timer.</summary>
        /// <returns>
        /// The frequency of the timer, in Hz, or zero if an
        /// [error](
        /// 
        /// Possible errors include
        /// 
        /// _safety This function may be called from any thread.
        /// </returns>
        public static ulong GetTimerFrequency()
        {
            var __ret = __Internal.GetTimerFrequency_0();
            return __ret;
        }

        /// <summary>
        ///   This function makes the OpenGL or OpenGL ES context of the specified window
        ///   current on the calling thread.  A context can only be made current on
        ///   a single thread at a time and each thread can have only a single current
        ///   context at a time.
        ///   By default, making a context non-current implicitly forces a pipeline flush.
        ///   On machines that support `GL_KHR_context_flush_control`, you can control
        ///   whether a context performs this flush by setting the
        ///   [GLFW_CONTEXT_RELEASE_BEHAVIOR](
        ///   The specified window must have an OpenGL or OpenGL ES context.  Specifying
        ///   a window without a context will generate a 
        ///   error.
        /// </summary>
        /// <param name="window">
        /// The window whose context to make current, or `NULL` to
        /// detach the current context.
        /// 
        /// Possible errors include
        /// GLFW_NO_WINDOW_CONTEXT and
        /// 
        /// _safety This function may be called from any thread.
        /// </param>
        public static void MakeContextCurrent(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.MakeContextCurrent_0(__arg0);
        }

        /// <summary>
        ///   This function returns the window whose OpenGL or OpenGL ES context is
        ///   current on the calling thread.
        /// </summary>
        /// <returns>
        /// The window whose context is current, or `NULL` if no window's
        /// context is current.
        /// 
        /// Possible errors include
        /// 
        /// _safety This function may be called from any thread.
        /// </returns>
        public static global::glfw3.GLFWwindow GetCurrentContext()
        {
            var __ret = __Internal.GetCurrentContext_0();
            global::glfw3.GLFWwindow __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.GLFWwindow.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.GLFWwindow) global::glfw3.GLFWwindow.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.GLFWwindow.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        ///   This function swaps the front and back buffers of the specified window when
        ///   rendering with OpenGL or OpenGL ES.  If the swap interval is greater than
        ///   zero, the GPU driver waits the specified number of screen updates before
        ///   swapping the buffers.
        ///   The specified window must have an OpenGL or OpenGL ES context.  Specifying
        ///   a window without a context will generate a 
        ///   error.
        ///   This function does not apply to Vulkan.  If you are rendering with Vulkan,
        ///   see `vkQueuePresentKHR` instead.
        /// </summary>
        /// <param name="window">
        /// The window whose buffers to swap.
        /// 
        /// Possible errors include
        /// GLFW_NO_WINDOW_CONTEXT and
        /// 
        /// 
        /// _safety This function may be called from any thread.
        /// </param>
        public static void SwapBuffers(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SwapBuffers_0(__arg0);
        }

        /// <summary>
        ///   This function sets the swap interval for the current OpenGL or OpenGL ES
        ///   context, i.e. the number of screen updates to wait from the time 
        ///   glfwSwapBuffers was called before swapping the buffers and returning.  This
        ///   is sometimes called _vertical synchronization_, _vertical retrace
        ///   synchronization_ or just _vsync_.
        ///   Contexts that support either of the `WGL_EXT_swap_control_tear` and
        ///   `GLX_EXT_swap_control_tear` extensions also accept negative swap intervals,
        ///   which allow the driver to swap even if a frame arrives a little bit late.
        ///   You can check for the presence of these extensions using 
        ///   glfwExtensionSupported.  For more information about swap tearing, see the
        ///   extension specifications.
        ///   A context must be current on the calling thread.  Calling this function
        ///   without a current context will cause a 
        ///   This function does not apply to Vulkan.  If you are rendering with Vulkan,
        ///   see the present mode of your swapchain instead.
        /// </summary>
        /// <param name="interval">
        /// The minimum number of screen updates to wait for
        /// until the buffers are swapped by
        /// 
        /// Possible errors include
        /// GLFW_NO_CURRENT_CONTEXT and
        /// 
        /// 
        /// 
        /// _safety This function may be called from any thread.
        /// </param>
        public static void SwapInterval(int interval)
        {
            __Internal.SwapInterval_0(interval);
        }

        /// <summary>
        ///   This function returns whether the specified
        ///   [API extension](
        ///   OpenGL ES context.  It searches both for client API extension and context
        ///   creation API extensions.
        ///   A context must be current on the calling thread.  Calling this function
        ///   without a current context will cause a 
        ///   As this functions retrieves and searches one or more extension strings each
        ///   call, it is recommended that you cache its results if it is going to be used
        ///   frequently.  The extension strings will not change during the lifetime of
        ///   a context, so there is no danger in doing this.
        ///   This function does not apply to Vulkan.  If you are using Vulkan, see 
        ///   glfwGetRequiredInstanceExtensions, `vkEnumerateInstanceExtensionProperties`
        ///   and `vkEnumerateDeviceExtensionProperties` instead.
        /// </summary>
        /// <param name="extension">The ASCII encoded name of the extension.</param>
        /// <returns>
        /// `GLFW_TRUE` if the extension is available, or `GLFW_FALSE`
        /// otherwise.
        /// 
        /// Possible errors include
        /// GLFW_NO_CURRENT_CONTEXT,
        /// GLFW_PLATFORM_ERROR.
        /// 
        /// _safety This function may be called from any thread.
        /// </returns>
        public static int ExtensionSupported(string extension)
        {
            var __ret = __Internal.ExtensionSupported_0(extension);
            return __ret;
        }

        /// <summary>
        ///   This function returns the address of the specified OpenGL or OpenGL ES
        ///   [core or extension function](
        ///   by the current context.
        ///   A context must be current on the calling thread.  Calling this function
        ///   without a current context will cause a 
        ///   This function does not apply to Vulkan.  If you are rendering with Vulkan,
        ///   see 
        ///   `vkGetDeviceProcAddr` instead.
        /// </summary>
        /// <param name="procname">The ASCII encoded name of the function.</param>
        /// <returns>
        /// The address of the function, or `NULL` if an
        /// [error](
        /// 
        /// Possible errors include
        /// GLFW_NO_CURRENT_CONTEXT and
        /// 
        /// 
        /// 
        /// _lifetime The returned function pointer is valid until the context
        /// is destroyed or the library is terminated.
        /// 
        /// _safety This function may be called from any thread.
        /// </returns>
        public static global::glfw3.GLFWglproc GetProcAddress(string procname)
        {
            var __ret = __Internal.GetProcAddress_0(procname);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWglproc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWglproc));
        }

        /// <summary>
        ///   This function returns whether the Vulkan loader has been found.  This check
        ///   is performed by 
        ///   The availability of a Vulkan loader does not by itself guarantee that window
        ///   surface creation or even device creation is possible.  Call 
        ///   glfwGetRequiredInstanceExtensions to check whether the extensions necessary
        ///   for Vulkan surface creation are available and 
        ///   glfwGetPhysicalDevicePresentationSupport to check whether a queue family of
        ///   a physical device supports image presentation.
        /// </summary>
        /// <returns>
        /// `GLFW_TRUE` if Vulkan is available, or `GLFW_FALSE` otherwise.
        /// 
        /// Possible errors include
        /// 
        /// _safety This function may be called from any thread.
        /// </returns>
        public static int VulkanSupported()
        {
            var __ret = __Internal.VulkanSupported_0();
            return __ret;
        }

        /// <summary>
        ///   This function returns an array of names of Vulkan instance extensions required
        ///   by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the
        ///   list will always contains `VK_KHR_surface`, so if you don't require any
        ///   additional extensions you can pass this list directly to the
        ///   `VkInstanceCreateInfo` struct.
        ///   If Vulkan is not available on the machine, this function returns `NULL` and
        ///   generates a 
        ///   to check whether Vulkan is available.
        ///   If Vulkan is available but no set of extensions allowing window surface
        ///   creation was found, this function returns `NULL`.  You may still use Vulkan
        ///   for off-screen rendering and compute work.
        /// </summary>
        /// <param name="count">
        /// Where to store the number of extensions in the returned
        /// array.  This is set to zero if an error occurred.
        /// </param>
        /// <returns>
        /// An array of ASCII encoded extension names, or `NULL` if an
        /// [error](
        /// 
        /// Possible errors include
        /// GLFW_API_UNAVAILABLE.
        /// 
        /// 
        /// _lifetime The returned array is allocated and freed by GLFW.  You
        /// should not free it yourself.  It is guaranteed to be valid only until the
        /// library is terminated.
        /// 
        /// _safety This function may be called from any thread.
        /// </returns>
        public static sbyte** GetRequiredInstanceExtensions(ref uint count)
        {
            fixed (uint* __refParamPtr0 = &count)
            {
                var __arg0 = __refParamPtr0;
                var __ret = __Internal.GetRequiredInstanceExtensions_0(__arg0);
                return __ret;
            }
        }
    }
}
