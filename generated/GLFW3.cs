// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace glfw3
{
    public enum KEY
    {
        UNKNOWN = 0,
        SPACE = 32,
        APOSTROPHE = 39,
        COMMA = 44,
        MINUS = 45,
        PERIOD = 46,
        SLASH = 47,
        _0 = 48,
        _1 = 49,
        _2 = 50,
        _3 = 51,
        _4 = 52,
        _5 = 53,
        _6 = 54,
        _7 = 55,
        _8 = 56,
        _9 = 57,
        SEMICOLON = 59,
        EQUAL = 61,
        A = 65,
        B = 66,
        C = 67,
        D = 68,
        E = 69,
        F = 70,
        G = 71,
        H = 72,
        I = 73,
        J = 74,
        K = 75,
        L = 76,
        M = 77,
        N = 78,
        O = 79,
        P = 80,
        Q = 81,
        R = 82,
        S = 83,
        T = 84,
        U = 85,
        V = 86,
        W = 87,
        X = 88,
        Y = 89,
        Z = 90,
        LEFT_BRACKET = 91,
        BACKSLASH = 92,
        RIGHT_BRACKET = 93,
        GRAVE_ACCENT = 96,
        WORLD_1 = 161,
        WORLD_2 = 162,
        ESCAPE = 256,
        ENTER = 257,
        TAB = 258,
        BACKSPACE = 259,
        INSERT = 260,
        DELETE = 261,
        RIGHT = 262,
        LEFT = 263,
        DOWN = 264,
        UP = 265,
        PAGE_UP = 266,
        PAGE_DOWN = 267,
        HOME = 268,
        END = 269,
        CAPS_LOCK = 280,
        SCROLL_LOCK = 281,
        NUM_LOCK = 282,
        PRINT_SCREEN = 283,
        PAUSE = 284,
        F1 = 290,
        F2 = 291,
        F3 = 292,
        F4 = 293,
        F5 = 294,
        F6 = 295,
        F7 = 296,
        F8 = 297,
        F9 = 298,
        F10 = 299,
        F11 = 300,
        F12 = 301,
        F13 = 302,
        F14 = 303,
        F15 = 304,
        F16 = 305,
        F17 = 306,
        F18 = 307,
        F19 = 308,
        F20 = 309,
        F21 = 310,
        F22 = 311,
        F23 = 312,
        F24 = 313,
        F25 = 314,
        KP_0 = 320,
        KP_1 = 321,
        KP_2 = 322,
        KP_3 = 323,
        KP_4 = 324,
        KP_5 = 325,
        KP_6 = 326,
        KP_7 = 327,
        KP_8 = 328,
        KP_9 = 329,
        KP_DECIMAL = 330,
        KP_DIVIDE = 331,
        KP_MULTIPLY = 332,
        KP_SUBTRACT = 333,
        KP_ADD = 334,
        KP_ENTER = 335,
        KP_EQUAL = 336,
        LEFT_SHIFT = 340,
        LEFT_CONTROL = 341,
        LEFT_ALT = 342,
        LEFT_SUPER = 343,
        RIGHT_SHIFT = 344,
        RIGHT_CONTROL = 345,
        RIGHT_ALT = 346,
        RIGHT_SUPER = 347,
        MENU = 348,
        LAST = 0,
        KY_KEYS = 0
    }

    public enum MOUSE
    {
        BUTTON_1 = 0,
        BUTTON_2 = 1,
        BUTTON_3 = 2,
        BUTTON_4 = 3,
        BUTTON_5 = 4,
        BUTTON_6 = 5,
        BUTTON_7 = 6,
        BUTTON_8 = 7,
        BUTTON_LAST = 0,
        BUTTON_LEFT = 0,
        BUTTON_RIGHT = 0,
        BUTTON_MIDDLE = 0,
        MOUSE_BUTTONS = 0
    }

    public enum JOYSTICK
    {
        _1 = 0,
        _2 = 1,
        _3 = 2,
        _4 = 3,
        _5 = 4,
        _6 = 5,
        _7 = 6,
        _8 = 7,
        _9 = 8,
        _10 = 9,
        _11 = 10,
        _12 = 11,
        _13 = 12,
        _14 = 13,
        _15 = 14,
        _16 = 15,
        LAST = 0
    }

    // <remarks>
    // <para>  Generic function pointer used for returning client API function pointers</para>
    // <para>  without forcing a cast from a regular pointer.</para>
    // </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWglproc();

    // <remarks>
    // <para>  Generic function pointer used for returning Vulkan API function pointers</para>
    // <para>  without forcing a cast from a regular pointer.</para>
    // </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWvkproc();

    // <remarks>  Opaque monitor object.</remarks>
    // <remarks>  Opaque window object.</remarks>
    // <remarks>  Opaque cursor object.</remarks>
    // <remarks>  This is the function signature for error callback functions.</remarks>
    // <param name="error">An [error code](</param>
    // <param name="description">A UTF-8 encoded string describing the error.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWerrorfun(int _0, [MarshalAs(UnmanagedType.LPStr)] string _1);

    // <remarks>  This is the function signature for window position callback functions.</remarks>
    // <param name="window">The window that was moved.</param>
    // <param name="xpos">
    // <para>The new x-coordinate, in screen coordinates, of the</para>
    // <para>upper-left corner of the client area of the window.</para>
    // </param>
    // <param name="ypos">
    // <para>The new y-coordinate, in screen coordinates, of the</para>
    // <para>upper-left corner of the client area of the window.</para>
    // </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowposfun(global::System.IntPtr _0, int _1, int _2);

    // <remarks>  This is the function signature for window size callback functions.</remarks>
    // <param name="window">The window that was resized.</param>
    // <param name="width">The new width, in screen coordinates, of the window.</param>
    // <param name="height">The new height, in screen coordinates, of the window.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowsizefun(global::System.IntPtr _0, int _1, int _2);

    // <remarks>  This is the function signature for window close callback functions.</remarks>
    // <param name="window">The window that the user attempted to close.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowclosefun(global::System.IntPtr _0);

    // <remarks>  This is the function signature for window refresh callback functions.</remarks>
    // <param name="window">The window whose content needs to be refreshed.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowrefreshfun(global::System.IntPtr _0);

    // <remarks>  This is the function signature for window focus callback functions.</remarks>
    // <param name="window">The window that gained or lost input focus.</param>
    // <param name="focused">
    // <para>`GLFW_TRUE` if the window was given input focus, or</para>
    // <para>`GLFW_FALSE` if it lost it.</para>
    // </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowfocusfun(global::System.IntPtr _0, int _1);

    // <remarks>
    // <para>  This is the function signature for window iconify/restore callback</para>
    // <para>  functions.</para>
    // </remarks>
    // <param name="window">The window that was iconified or restored.</param>
    // <param name="iconified">
    // <para>`GLFW_TRUE` if the window was iconified, or</para>
    // <para>`GLFW_FALSE` if it was restored.</para>
    // </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowiconifyfun(global::System.IntPtr _0, int _1);

    // <remarks>
    // <para>  This is the function signature for framebuffer resize callback</para>
    // <para>  functions.</para>
    // </remarks>
    // <param name="window">The window whose framebuffer was resized.</param>
    // <param name="width">The new width, in pixels, of the framebuffer.</param>
    // <param name="height">The new height, in pixels, of the framebuffer.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWframebuffersizefun(global::System.IntPtr _0, int _1, int _2);

    // <remarks>  This is the function signature for mouse button callback functions.</remarks>
    // <param name="window">The window that received the event.</param>
    // <param name="button">
    // <para>The [mouse button](</para>
    // <para>released.</para>
    // </param>
    // <param name="action">One of `GLFW_PRESS` or `GLFW_RELEASE`.</param>
    // <param name="mods">
    // <para>Bit field describing which [modifier keys](</para>
    // <para>held down.</para>
    // </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWmousebuttonfun(global::System.IntPtr _0, int _1, int _2, int _3);

    // <remarks>  This is the function signature for cursor position callback functions.</remarks>
    // <param name="window">The window that received the event.</param>
    // <param name="xpos">
    // <para>The new cursor x-coordinate, relative to the left edge of</para>
    // <para>the client area.</para>
    // </param>
    // <param name="ypos">
    // <para>The new cursor y-coordinate, relative to the top edge of the</para>
    // <para>client area.</para>
    // </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWcursorposfun(global::System.IntPtr _0, double _1, double _2);

    // <remarks>  This is the function signature for cursor enter/leave callback functions.</remarks>
    // <param name="window">The window that received the event.</param>
    // <param name="entered">
    // <para>`GLFW_TRUE` if the cursor entered the window's client</para>
    // <para>area, or `GLFW_FALSE` if it left it.</para>
    // </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWcursorenterfun(global::System.IntPtr _0, int _1);

    // <remarks>  This is the function signature for scroll callback functions.</remarks>
    // <param name="window">The window that received the event.</param>
    // <param name="xoffset">The scroll offset along the x-axis.</param>
    // <param name="yoffset">The scroll offset along the y-axis.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWscrollfun(global::System.IntPtr _0, double _1, double _2);

    // <remarks>  This is the function signature for keyboard key callback functions.</remarks>
    // <param name="window">The window that received the event.</param>
    // <param name="key">The [keyboard key](</param>
    // <param name="scancode">The system-specific scancode of the key.</param>
    // <param name="action">`GLFW_PRESS`, `GLFW_RELEASE` or `GLFW_REPEAT`.</param>
    // <param name="mods">
    // <para>Bit field describing which [modifier keys](</para>
    // <para>held down.</para>
    // </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWkeyfun(global::System.IntPtr _0, int _1, int _2, int _3, int _4);

    // <remarks>  This is the function signature for Unicode character callback functions.</remarks>
    // <param name="window">The window that received the event.</param>
    // <param name="codepoint">The Unicode code point of the character.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWcharfun(global::System.IntPtr _0, uint _1);

    // <remarks>
    // <para>  This is the function signature for Unicode character with modifiers callback</para>
    // <para>  functions.  It is called for each input character, regardless of what</para>
    // <para>  modifier keys are held down.</para>
    // </remarks>
    // <param name="window">The window that received the event.</param>
    // <param name="codepoint">The Unicode code point of the character.</param>
    // <param name="mods">
    // <para>Bit field describing which [modifier keys](</para>
    // <para>held down.</para>
    // </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWcharmodsfun(global::System.IntPtr _0, uint _1, int _2);

    // <remarks>  This is the function signature for file drop callbacks.</remarks>
    // <param name="window">The window that received the event.</param>
    // <param name="count">The number of dropped files.</param>
    // <param name="paths">The UTF-8 encoded file and/or directory path names.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWdropfun(global::System.IntPtr _0, int _1, sbyte** _2);

    // <remarks>  This is the function signature for monitor configuration callback functions.</remarks>
    // <param name="monitor">The monitor that was connected or disconnected.</param>
    // <param name="event">One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWmonitorfun(global::System.IntPtr _0, int _1);

    // <remarks>
    // <para>  This is the function signature for joystick configuration callback</para>
    // <para>  functions.</para>
    // </remarks>
    // <param name="joy">The joystick that was connected or disconnected.</param>
    // <param name="event">One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWjoystickfun(int _0, int _1);

    public unsafe partial class GLFWmonitor
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWmonitor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWmonitor>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::glfw3.GLFWmonitor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new GLFWmonitor(native.ToPointer(), skipVTables);
        }

        internal static global::glfw3.GLFWmonitor __CreateInstance(global::glfw3.GLFWmonitor.__Internal native, bool skipVTables = false)
        {
            return new GLFWmonitor(native, skipVTables);
        }

        private static void* __CopyValue(global::glfw3.GLFWmonitor.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWmonitor.__Internal));
            *(global::glfw3.GLFWmonitor.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWmonitor(global::glfw3.GLFWmonitor.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWmonitor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class GLFWwindow
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWwindow> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWwindow>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::glfw3.GLFWwindow __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new GLFWwindow(native.ToPointer(), skipVTables);
        }

        internal static global::glfw3.GLFWwindow __CreateInstance(global::glfw3.GLFWwindow.__Internal native, bool skipVTables = false)
        {
            return new GLFWwindow(native, skipVTables);
        }

        private static void* __CopyValue(global::glfw3.GLFWwindow.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWwindow.__Internal));
            *(global::glfw3.GLFWwindow.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWwindow(global::glfw3.GLFWwindow.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWwindow(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class GLFWcursor
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWcursor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWcursor>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::glfw3.GLFWcursor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new GLFWcursor(native.ToPointer(), skipVTables);
        }

        internal static global::glfw3.GLFWcursor __CreateInstance(global::glfw3.GLFWcursor.__Internal native, bool skipVTables = false)
        {
            return new GLFWcursor(native, skipVTables);
        }

        private static void* __CopyValue(global::glfw3.GLFWcursor.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWcursor.__Internal));
            *(global::glfw3.GLFWcursor.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWcursor(global::glfw3.GLFWcursor.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWcursor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    // <remarks>  This describes a single video mode.</remarks>
    public unsafe partial class GLFWvidmode : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int width;

            [FieldOffset(4)]
            public int height;

            [FieldOffset(8)]
            public int redBits;

            [FieldOffset(12)]
            public int greenBits;

            [FieldOffset(16)]
            public int blueBits;

            [FieldOffset(20)]
            public int refreshRate;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0GLFWvidmode@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWvidmode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWvidmode>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::glfw3.GLFWvidmode __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new GLFWvidmode(native.ToPointer(), skipVTables);
        }

        internal static global::glfw3.GLFWvidmode __CreateInstance(global::glfw3.GLFWvidmode.__Internal native, bool skipVTables = false)
        {
            return new GLFWvidmode(native, skipVTables);
        }

        private static void* __CopyValue(global::glfw3.GLFWvidmode.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWvidmode.__Internal));
            *(global::glfw3.GLFWvidmode.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWvidmode(global::glfw3.GLFWvidmode.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWvidmode(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public GLFWvidmode()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWvidmode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public GLFWvidmode(global::glfw3.GLFWvidmode _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWvidmode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::glfw3.GLFWvidmode.__Internal*) __Instance) = *((global::glfw3.GLFWvidmode.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::glfw3.GLFWvidmode __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public int Width
        {
            get
            {
                return ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->width;
            }

            set
            {
                ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->width = value;
            }
        }

        public int Height
        {
            get
            {
                return ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->height;
            }

            set
            {
                ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->height = value;
            }
        }

        public int RedBits
        {
            get
            {
                return ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->redBits;
            }

            set
            {
                ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->redBits = value;
            }
        }

        public int GreenBits
        {
            get
            {
                return ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->greenBits;
            }

            set
            {
                ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->greenBits = value;
            }
        }

        public int BlueBits
        {
            get
            {
                return ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->blueBits;
            }

            set
            {
                ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->blueBits = value;
            }
        }

        public int RefreshRate
        {
            get
            {
                return ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->refreshRate;
            }

            set
            {
                ((global::glfw3.GLFWvidmode.__Internal*) __Instance)->refreshRate = value;
            }
        }
    }

    // <remarks>  This describes the gamma ramp for a monitor.</remarks>
    public unsafe partial class GLFWgammaramp : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr red;

            [FieldOffset(4)]
            public global::System.IntPtr green;

            [FieldOffset(8)]
            public global::System.IntPtr blue;

            [FieldOffset(12)]
            public uint size;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0GLFWgammaramp@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWgammaramp> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWgammaramp>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::glfw3.GLFWgammaramp __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new GLFWgammaramp(native.ToPointer(), skipVTables);
        }

        internal static global::glfw3.GLFWgammaramp __CreateInstance(global::glfw3.GLFWgammaramp.__Internal native, bool skipVTables = false)
        {
            return new GLFWgammaramp(native, skipVTables);
        }

        private static void* __CopyValue(global::glfw3.GLFWgammaramp.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWgammaramp.__Internal));
            *(global::glfw3.GLFWgammaramp.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWgammaramp(global::glfw3.GLFWgammaramp.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWgammaramp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public GLFWgammaramp()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWgammaramp.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public GLFWgammaramp(global::glfw3.GLFWgammaramp _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWgammaramp.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::glfw3.GLFWgammaramp.__Internal*) __Instance) = *((global::glfw3.GLFWgammaramp.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::glfw3.GLFWgammaramp __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public ushort* Red
        {
            get
            {
                return (ushort*) ((global::glfw3.GLFWgammaramp.__Internal*) __Instance)->red;
            }

            set
            {
                ((global::glfw3.GLFWgammaramp.__Internal*) __Instance)->red = (global::System.IntPtr) value;
            }
        }

        public ushort* Green
        {
            get
            {
                return (ushort*) ((global::glfw3.GLFWgammaramp.__Internal*) __Instance)->green;
            }

            set
            {
                ((global::glfw3.GLFWgammaramp.__Internal*) __Instance)->green = (global::System.IntPtr) value;
            }
        }

        public ushort* Blue
        {
            get
            {
                return (ushort*) ((global::glfw3.GLFWgammaramp.__Internal*) __Instance)->blue;
            }

            set
            {
                ((global::glfw3.GLFWgammaramp.__Internal*) __Instance)->blue = (global::System.IntPtr) value;
            }
        }

        public uint Size
        {
            get
            {
                return ((global::glfw3.GLFWgammaramp.__Internal*) __Instance)->size;
            }

            set
            {
                ((global::glfw3.GLFWgammaramp.__Internal*) __Instance)->size = value;
            }
        }
    }


    public unsafe partial class GLFWimage : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int width;

            [FieldOffset(4)]
            public int height;

            [FieldOffset(8)]
            public global::System.IntPtr pixels;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0GLFWimage@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWimage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.GLFWimage>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::glfw3.GLFWimage __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new GLFWimage(native.ToPointer(), skipVTables);
        }

        internal static global::glfw3.GLFWimage __CreateInstance(global::glfw3.GLFWimage.__Internal native, bool skipVTables = false)
        {
            return new GLFWimage(native, skipVTables);
        }

        private static void* __CopyValue(global::glfw3.GLFWimage.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWimage.__Internal));
            *(global::glfw3.GLFWimage.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWimage(global::glfw3.GLFWimage.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWimage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public GLFWimage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWimage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public GLFWimage(global::glfw3.GLFWimage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::glfw3.GLFWimage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::glfw3.GLFWimage.__Internal*) __Instance) = *((global::glfw3.GLFWimage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::glfw3.GLFWimage __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public int Width
        {
            get
            {
                return ((global::glfw3.GLFWimage.__Internal*) __Instance)->width;
            }

            set
            {
                ((global::glfw3.GLFWimage.__Internal*) __Instance)->width = value;
            }
        }

        public int Height
        {
            get
            {
                return ((global::glfw3.GLFWimage.__Internal*) __Instance)->height;
            }

            set
            {
                ((global::glfw3.GLFWimage.__Internal*) __Instance)->height = value;
            }
        }

        public byte* Pixels
        {
            get
            {
                return (byte*) ((global::glfw3.GLFWimage.__Internal*) __Instance)->pixels;
            }

            set
            {
                ((global::glfw3.GLFWimage.__Internal*) __Instance)->pixels = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class Test : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Test@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.Test> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::glfw3.Test>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::glfw3.Test __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Test(native.ToPointer(), skipVTables);
        }

        internal static global::glfw3.Test __CreateInstance(global::glfw3.Test.__Internal native, bool skipVTables = false)
        {
            return new Test(native, skipVTables);
        }

        private static void* __CopyValue(global::glfw3.Test.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::glfw3.Test.__Internal));
            *(global::glfw3.Test.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Test(global::glfw3.Test.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Test(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Test()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::glfw3.Test.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Test(global::glfw3.Test _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::glfw3.Test.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::glfw3.Test.__Internal*) __Instance) = *((global::glfw3.Test.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::glfw3.Test __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class glfw3
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwInit")]
            internal static extern int GlfwInit_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwTerminate")]
            internal static extern void GlfwTerminate_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="getTests")]
            internal static extern global::System.IntPtr GetTests_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetVersion")]
            internal static extern void GlfwGetVersion_0(int* major, int* minor, int* rev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetVersionString")]
            internal static extern global::System.IntPtr GlfwGetVersionString_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetErrorCallback")]
            internal static extern global::System.IntPtr GlfwSetErrorCallback_0(global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetMonitors")]
            internal static extern global::System.IntPtr GlfwGetMonitors_0(int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetPrimaryMonitor")]
            internal static extern global::System.IntPtr GlfwGetPrimaryMonitor_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetMonitorPos")]
            internal static extern void GlfwGetMonitorPos_0(global::System.IntPtr monitor, int* xpos, int* ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetMonitorPhysicalSize")]
            internal static extern void GlfwGetMonitorPhysicalSize_0(global::System.IntPtr monitor, int* widthMM, int* heightMM);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetMonitorName")]
            internal static extern global::System.IntPtr GlfwGetMonitorName_0(global::System.IntPtr monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetMonitorCallback")]
            internal static extern global::System.IntPtr GlfwSetMonitorCallback_0(global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetVideoModes")]
            internal static extern global::System.IntPtr GlfwGetVideoModes_0(global::System.IntPtr monitor, int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetVideoMode")]
            internal static extern global::System.IntPtr GlfwGetVideoMode_0(global::System.IntPtr monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetGamma")]
            internal static extern void GlfwSetGamma_0(global::System.IntPtr monitor, float gamma);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetGammaRamp")]
            internal static extern global::System.IntPtr GlfwGetGammaRamp_0(global::System.IntPtr monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetGammaRamp")]
            internal static extern void GlfwSetGammaRamp_0(global::System.IntPtr monitor, global::System.IntPtr ramp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwDefaultWindowHints")]
            internal static extern void GlfwDefaultWindowHints_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwWindowHint")]
            internal static extern void GlfwWindowHint_0(int hint, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwCreateWindow")]
            internal static extern global::System.IntPtr GlfwCreateWindow_0(int width, int height, [MarshalAs(UnmanagedType.LPStr)] string title, global::System.IntPtr monitor, global::System.IntPtr share);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwDestroyWindow")]
            internal static extern void GlfwDestroyWindow_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwWindowShouldClose")]
            internal static extern int GlfwWindowShouldClose_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowShouldClose")]
            internal static extern void GlfwSetWindowShouldClose_0(global::System.IntPtr window, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowTitle")]
            internal static extern void GlfwSetWindowTitle_0(global::System.IntPtr window, [MarshalAs(UnmanagedType.LPStr)] string title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowIcon")]
            internal static extern void GlfwSetWindowIcon_0(global::System.IntPtr window, int count, global::System.IntPtr images);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowPos")]
            internal static extern void GlfwGetWindowPos_0(global::System.IntPtr window, int* xpos, int* ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowPos")]
            internal static extern void GlfwSetWindowPos_0(global::System.IntPtr window, int xpos, int ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowSize")]
            internal static extern void GlfwGetWindowSize_0(global::System.IntPtr window, int* width, int* height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowSizeLimits")]
            internal static extern void GlfwSetWindowSizeLimits_0(global::System.IntPtr window, int minwidth, int minheight, int maxwidth, int maxheight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowAspectRatio")]
            internal static extern void GlfwSetWindowAspectRatio_0(global::System.IntPtr window, int numer, int denom);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowSize")]
            internal static extern void GlfwSetWindowSize_0(global::System.IntPtr window, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetFramebufferSize")]
            internal static extern void GlfwGetFramebufferSize_0(global::System.IntPtr window, int* width, int* height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowFrameSize")]
            internal static extern void GlfwGetWindowFrameSize_0(global::System.IntPtr window, int* left, int* top, int* right, int* bottom);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwIconifyWindow")]
            internal static extern void GlfwIconifyWindow_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwRestoreWindow")]
            internal static extern void GlfwRestoreWindow_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwMaximizeWindow")]
            internal static extern void GlfwMaximizeWindow_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwShowWindow")]
            internal static extern void GlfwShowWindow_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwHideWindow")]
            internal static extern void GlfwHideWindow_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwFocusWindow")]
            internal static extern void GlfwFocusWindow_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowMonitor")]
            internal static extern global::System.IntPtr GlfwGetWindowMonitor_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowMonitor")]
            internal static extern void GlfwSetWindowMonitor_0(global::System.IntPtr window, global::System.IntPtr monitor, int xpos, int ypos, int width, int height, int refreshRate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowAttrib")]
            internal static extern int GlfwGetWindowAttrib_0(global::System.IntPtr window, int attrib);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowUserPointer")]
            internal static extern void GlfwSetWindowUserPointer_0(global::System.IntPtr window, global::System.IntPtr pointer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowUserPointer")]
            internal static extern global::System.IntPtr GlfwGetWindowUserPointer_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowPosCallback")]
            internal static extern global::System.IntPtr GlfwSetWindowPosCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowSizeCallback")]
            internal static extern global::System.IntPtr GlfwSetWindowSizeCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowCloseCallback")]
            internal static extern global::System.IntPtr GlfwSetWindowCloseCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowRefreshCallback")]
            internal static extern global::System.IntPtr GlfwSetWindowRefreshCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowFocusCallback")]
            internal static extern global::System.IntPtr GlfwSetWindowFocusCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowIconifyCallback")]
            internal static extern global::System.IntPtr GlfwSetWindowIconifyCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetFramebufferSizeCallback")]
            internal static extern global::System.IntPtr GlfwSetFramebufferSizeCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwPollEvents")]
            internal static extern void GlfwPollEvents_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwWaitEvents")]
            internal static extern void GlfwWaitEvents_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwWaitEventsTimeout")]
            internal static extern void GlfwWaitEventsTimeout_0(double timeout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwPostEmptyEvent")]
            internal static extern void GlfwPostEmptyEvent_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetInputMode")]
            internal static extern int GlfwGetInputMode_0(global::System.IntPtr window, int mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetInputMode")]
            internal static extern void GlfwSetInputMode_0(global::System.IntPtr window, int mode, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetKeyName")]
            internal static extern global::System.IntPtr GlfwGetKeyName_0(int key, int scancode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetKey")]
            internal static extern int GlfwGetKey_0(global::System.IntPtr window, int key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetMouseButton")]
            internal static extern int GlfwGetMouseButton_0(global::System.IntPtr window, int button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetCursorPos")]
            internal static extern void GlfwGetCursorPos_0(global::System.IntPtr window, double* xpos, double* ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCursorPos")]
            internal static extern void GlfwSetCursorPos_0(global::System.IntPtr window, double xpos, double ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwCreateCursor")]
            internal static extern global::System.IntPtr GlfwCreateCursor_0(global::System.IntPtr image, int xhot, int yhot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwCreateStandardCursor")]
            internal static extern global::System.IntPtr GlfwCreateStandardCursor_0(int shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwDestroyCursor")]
            internal static extern void GlfwDestroyCursor_0(global::System.IntPtr cursor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCursor")]
            internal static extern void GlfwSetCursor_0(global::System.IntPtr window, global::System.IntPtr cursor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetKeyCallback")]
            internal static extern global::System.IntPtr GlfwSetKeyCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCharCallback")]
            internal static extern global::System.IntPtr GlfwSetCharCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCharModsCallback")]
            internal static extern global::System.IntPtr GlfwSetCharModsCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetMouseButtonCallback")]
            internal static extern global::System.IntPtr GlfwSetMouseButtonCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCursorPosCallback")]
            internal static extern global::System.IntPtr GlfwSetCursorPosCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCursorEnterCallback")]
            internal static extern global::System.IntPtr GlfwSetCursorEnterCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetScrollCallback")]
            internal static extern global::System.IntPtr GlfwSetScrollCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetDropCallback")]
            internal static extern global::System.IntPtr GlfwSetDropCallback_0(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwJoystickPresent")]
            internal static extern int GlfwJoystickPresent_0(int joy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetJoystickAxes")]
            internal static extern float* GlfwGetJoystickAxes_0(int joy, int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetJoystickButtons")]
            internal static extern byte* GlfwGetJoystickButtons_0(int joy, int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetJoystickName")]
            internal static extern global::System.IntPtr GlfwGetJoystickName_0(int joy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetJoystickCallback")]
            internal static extern global::System.IntPtr GlfwSetJoystickCallback_0(global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetClipboardString")]
            internal static extern void GlfwSetClipboardString_0(global::System.IntPtr window, [MarshalAs(UnmanagedType.LPStr)] string @string);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetClipboardString")]
            internal static extern global::System.IntPtr GlfwGetClipboardString_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetTime")]
            internal static extern double GlfwGetTime_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetTime")]
            internal static extern void GlfwSetTime_0(double time);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetTimerValue")]
            internal static extern ulong GlfwGetTimerValue_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetTimerFrequency")]
            internal static extern ulong GlfwGetTimerFrequency_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwMakeContextCurrent")]
            internal static extern void GlfwMakeContextCurrent_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetCurrentContext")]
            internal static extern global::System.IntPtr GlfwGetCurrentContext_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSwapBuffers")]
            internal static extern void GlfwSwapBuffers_0(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSwapInterval")]
            internal static extern void GlfwSwapInterval_0(int interval);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwExtensionSupported")]
            internal static extern int GlfwExtensionSupported_0([MarshalAs(UnmanagedType.LPStr)] string extension);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetProcAddress")]
            internal static extern global::System.IntPtr GlfwGetProcAddress_0([MarshalAs(UnmanagedType.LPStr)] string procname);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwVulkanSupported")]
            internal static extern int GlfwVulkanSupported_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetRequiredInstanceExtensions")]
            internal static extern sbyte** GlfwGetRequiredInstanceExtensions_0(uint* count);
        }

        // <remarks>
        // <para>  This function initializes the GLFW library.  Before most GLFW functions can</para>
        // <para>  be used, GLFW must be initialized, and before an application terminates GLFW</para>
        // <para>  should be terminated in order to free any resources allocated during or</para>
        // <para>  after initialization.</para>
        // <para>  If this function fails, it calls </para>
        // <para>  succeeds, you should call </para>
        // <para>  Additional calls to this function after successful initialization but before</para>
        // <para>  termination will return `GLFW_TRUE` immediately.</para>
        // </remarks>
        // <returns>
        // <para>`GLFW_TRUE` if successful, or `GLFW_FALSE` if an</para>
        // <para>[error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static int GlfwInit()
        {
            var __ret = __Internal.GlfwInit_0();
            return __ret;
        }

        // <remarks>
        // <para>  This function destroys all remaining windows and cursors, restores any</para>
        // <para>  modified gamma ramps and frees any other allocated resources.  Once this</para>
        // <para>  function is called, you must again call </para>
        // <para>  you will be able to use most GLFW functions.</para>
        // <para>  If GLFW has been successfully initialized, this function should be called</para>
        // <para>  before the application exits.  If initialization fails, there is no need to</para>
        // <para>  call this function, as it is called by </para>
        // <para>  failure.</para>
        // <para>  </para>
        // <para>Possible errors include </para>
        // <para>  </para>
        // <para>  </para>
        // <para>  </para>
        // <para>This function must not be called from a callback.</para>
        // <para>  </para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </remarks>
        public static void GlfwTerminate()
        {
            __Internal.GlfwTerminate_0();
        }

        public static global::glfw3.Test GetTests()
        {
            var __ret = __Internal.GetTests_0();
            global::glfw3.Test __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.Test.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.Test) global::glfw3.Test.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.Test.__CreateInstance(__ret);
            return __result0;
        }

        // <remarks>
        // <para>  This function retrieves the major, minor and revision numbers of the GLFW</para>
        // <para>  library.  It is intended for when you are using GLFW as a shared library and</para>
        // <para>  want to ensure that you are using the minimum required version.</para>
        // <para>  Any or all of the version arguments may be `NULL`.</para>
        // </remarks>
        // <param name="major">Where to store the major version number, or `NULL`.</param>
        // <param name="minor">Where to store the minor version number, or `NULL`.</param>
        // <param name="rev">
        // <para>Where to store the revision number, or `NULL`.</para>
        // <para></para>
        // <para>None.</para>
        // <para></para>
        // <para></para>
        // <para>_safety This function may be called from any thread.</para>
        // </param>
        public static void GlfwGetVersion(ref int major, ref int minor, ref int rev)
        {
            fixed (int* __refParamPtr0 = &major)
            {
                var __arg0 = __refParamPtr0;
                fixed (int* __refParamPtr1 = &minor)
                {
                    var __arg1 = __refParamPtr1;
                    fixed (int* __refParamPtr2 = &rev)
                    {
                        var __arg2 = __refParamPtr2;
                        __Internal.GlfwGetVersion_0(__arg0, __arg1, __arg2);
                    }
                }
            }
        }

        // <remarks>
        // <para>  This function returns the compile-time generated</para>
        // <para>  [version string](</para>
        // <para>  describes the version, platform, compiler and any platform-specific</para>
        // <para>  compile-time options.  It should not be confused with the OpenGL or OpenGL</para>
        // <para>  ES version string, queried with `glGetString`.</para>
        // <para>  __Do not use the version string__ to parse the GLFW library version.  The</para>
        // <para>  </para>
        // <para>  binary in numerical format.</para>
        // </remarks>
        // <returns>
        // <para>The ASCII encoded GLFW version string.</para>
        // <para></para>
        // <para>None.</para>
        // <para></para>
        // <para></para>
        // <para>_lifetime The returned string is static and compile-time generated.</para>
        // <para></para>
        // <para>_safety This function may be called from any thread.</para>
        // </returns>
        public static string GlfwGetVersionString()
        {
            var __ret = __Internal.GlfwGetVersionString_0();
            return Marshal.PtrToStringAnsi(__ret);
        }

        // <remarks>
        // <para>  This function sets the error callback, which is called with an error code</para>
        // <para>  and a human-readable description each time a GLFW error occurs.</para>
        // <para>  The error callback is called on the thread where the error occurred.  If you</para>
        // <para>  are using GLFW from multiple threads, your error callback needs to be</para>
        // <para>  written accordingly.</para>
        // <para>  Because the description string may have been generated specifically for that</para>
        // <para>  error, it is not guaranteed to be valid after the callback has returned.  If</para>
        // <para>  you wish to use it after the callback returns, you need to make a copy.</para>
        // <para>  Once set, the error callback remains set even after the library has been</para>
        // <para>  terminated.</para>
        // </remarks>
        // <param name="cbfun">
        // <para>The new callback, or `NULL` to remove the currently set</para>
        // <para>callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set.</para>
        // <para></para>
        // <para>None.</para>
        // <para></para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWerrorfun GlfwSetErrorCallback(global::glfw3.GLFWerrorfun cbfun)
        {
            var __arg0 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetErrorCallback_0(__arg0);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWerrorfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWerrorfun));
        }

        // <remarks>
        // <para>  This function returns an array of handles for all currently connected</para>
        // <para>  monitors.  The primary monitor is always first in the returned array.  If no</para>
        // <para>  monitors were found, this function returns `NULL`.</para>
        // </remarks>
        // <param name="count">
        // <para>Where to store the number of monitors in the returned</para>
        // <para>array.  This is set to zero if an error occurred.</para>
        // </param>
        // <returns>
        // <para>An array of monitor handles, or `NULL` if no monitors were found or</para>
        // <para>if an [error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_lifetime The returned array is allocated and freed by GLFW.  You</para>
        // <para>should not free it yourself.  It is guaranteed to be valid only until the</para>
        // <para>monitor configuration changes or the library is terminated.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWmonitor GlfwGetMonitors(ref int count)
        {
            fixed (int* __refParamPtr0 = &count)
            {
                var __arg0 = __refParamPtr0;
                var __ret = __Internal.GlfwGetMonitors_0(__arg0);
                global::glfw3.GLFWmonitor __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::glfw3.GLFWmonitor.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::glfw3.GLFWmonitor) global::glfw3.GLFWmonitor.NativeToManagedMap[__ret];
                else __result0 = global::glfw3.GLFWmonitor.__CreateInstance(__ret);
                return __result0;
            }
        }

        // <remarks>
        // <para>  This function returns the primary monitor.  This is usually the monitor</para>
        // <para>  where elements like the task bar or global menu bar are located.</para>
        // </remarks>
        // <returns>
        // <para>The primary monitor, or `NULL` if no monitors were found or if an</para>
        // <para>[error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // <para></para>
        // <para>glfwGetMonitors.</para>
        // </returns>
        public static global::glfw3.GLFWmonitor GlfwGetPrimaryMonitor()
        {
            var __ret = __Internal.GlfwGetPrimaryMonitor_0();
            global::glfw3.GLFWmonitor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.GLFWmonitor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.GLFWmonitor) global::glfw3.GLFWmonitor.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.GLFWmonitor.__CreateInstance(__ret);
            return __result0;
        }

        // <remarks>
        // <para>  This function returns the position, in screen coordinates, of the upper-left</para>
        // <para>  corner of the specified monitor.</para>
        // <para>  Any or all of the position arguments may be `NULL`.  If an error occurs, all</para>
        // <para>  non-`NULL` position arguments will be set to zero.</para>
        // </remarks>
        // <param name="monitor">The monitor to query.</param>
        // <param name="xpos">Where to store the monitor x-coordinate, or `NULL`.</param>
        // <param name="ypos">
        // <para>Where to store the monitor y-coordinate, or `NULL`.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwGetMonitorPos(global::glfw3.GLFWmonitor monitor, ref int xpos, ref int ypos)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            fixed (int* __refParamPtr1 = &xpos)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &ypos)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GlfwGetMonitorPos_0(__arg0, __arg1, __arg2);
                }
            }
        }

        // <remarks>
        // <para>  This function returns the size, in millimetres, of the display area of the</para>
        // <para>  specified monitor.</para>
        // <para>  Some systems do not provide accurate monitor size information, either</para>
        // <para>  because the monitor</para>
        // <para>  [EDID](https://en.wikipedia.org/wiki/Extended_display_identification_data)</para>
        // <para>  data is incorrect or because the driver does not report it accurately.</para>
        // <para>  Any or all of the size arguments may be `NULL`.  If an error occurs, all</para>
        // <para>  non-`NULL` size arguments will be set to zero.</para>
        // </remarks>
        // <param name="monitor">The monitor to query.</param>
        // <param name="widthMM">
        // <para>Where to store the width, in millimetres, of the</para>
        // <para>monitor's display area, or `NULL`.</para>
        // </param>
        // <param name="heightMM">
        // <para>Where to store the height, in millimetres, of the</para>
        // <para>monitor's display area, or `NULL`.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwGetMonitorPhysicalSize(global::glfw3.GLFWmonitor monitor, ref int widthMM, ref int heightMM)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            fixed (int* __refParamPtr1 = &widthMM)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &heightMM)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GlfwGetMonitorPhysicalSize_0(__arg0, __arg1, __arg2);
                }
            }
        }

        // <remarks>
        // <para>  This function returns a human-readable name, encoded as UTF-8, of the</para>
        // <para>  specified monitor.  The name typically reflects the make and model of the</para>
        // <para>  monitor and is not guaranteed to be unique among the connected monitors.</para>
        // </remarks>
        // <param name="monitor">The monitor to query.</param>
        // <returns>
        // <para>The UTF-8 encoded name of the monitor, or `NULL` if an</para>
        // <para>[error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_lifetime The returned string is allocated and freed by GLFW.  You</para>
        // <para>should not free it yourself.  It is valid until the specified monitor is</para>
        // <para>disconnected or the library is terminated.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static string GlfwGetMonitorName(global::glfw3.GLFWmonitor monitor)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            var __ret = __Internal.GlfwGetMonitorName_0(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        // <remarks>
        // <para>  This function sets the monitor configuration callback, or removes the</para>
        // <para>  currently set callback.  This is called when a monitor is connected to or</para>
        // <para>  disconnected from the system.</para>
        // </remarks>
        // <param name="cbfun">
        // <para>The new callback, or `NULL` to remove the currently set</para>
        // <para>callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set or the</para>
        // <para>library had not been [initialized](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWmonitorfun GlfwSetMonitorCallback(global::glfw3.GLFWmonitorfun cbfun)
        {
            var __arg0 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetMonitorCallback_0(__arg0);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWmonitorfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWmonitorfun));
        }

        // <remarks>
        // <para>  This function returns an array of all video modes supported by the specified</para>
        // <para>  monitor.  The returned array is sorted in ascending order, first by color</para>
        // <para>  bit depth (the sum of all channel depths) and then by resolution area (the</para>
        // <para>  product of width and height).</para>
        // </remarks>
        // <param name="monitor">The monitor to query.</param>
        // <param name="count">
        // <para>Where to store the number of video modes in the returned</para>
        // <para>array.  This is set to zero if an error occurred.</para>
        // </param>
        // <returns>
        // <para>An array of video modes, or `NULL` if an</para>
        // <para>[error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_lifetime The returned array is allocated and freed by GLFW.  You</para>
        // <para>should not free it yourself.  It is valid until the specified monitor is</para>
        // <para>disconnected, this function is called again for that monitor or the library</para>
        // <para>is terminated.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWvidmode GlfwGetVideoModes(global::glfw3.GLFWmonitor monitor, ref int count)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            fixed (int* __refParamPtr1 = &count)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.GlfwGetVideoModes_0(__arg0, __arg1);
                global::glfw3.GLFWvidmode __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::glfw3.GLFWvidmode.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::glfw3.GLFWvidmode) global::glfw3.GLFWvidmode.NativeToManagedMap[__ret];
                else __result0 = global::glfw3.GLFWvidmode.__CreateInstance(__ret);
                return __result0;
            }
        }

        // <remarks>
        // <para>  This function returns the current video mode of the specified monitor.  If</para>
        // <para>  you have created a full screen window for that monitor, the return value</para>
        // <para>  will depend on whether that window is iconified.</para>
        // </remarks>
        // <param name="monitor">The monitor to query.</param>
        // <returns>
        // <para>The current mode of the monitor, or `NULL` if an</para>
        // <para>[error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_lifetime The returned array is allocated and freed by GLFW.  You</para>
        // <para>should not free it yourself.  It is valid until the specified monitor is</para>
        // <para>disconnected or the library is terminated.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWvidmode GlfwGetVideoMode(global::glfw3.GLFWmonitor monitor)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            var __ret = __Internal.GlfwGetVideoMode_0(__arg0);
            global::glfw3.GLFWvidmode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.GLFWvidmode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.GLFWvidmode) global::glfw3.GLFWvidmode.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.GLFWvidmode.__CreateInstance(__ret);
            return __result0;
        }

        // <remarks>
        // <para>  This function generates a 256-element gamma ramp from the specified exponent</para>
        // <para>  and then calls </para>
        // <para>  number greater than zero.</para>
        // </remarks>
        // <param name="monitor">The monitor whose gamma ramp to set.</param>
        // <param name="gamma">
        // <para>The desired exponent.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_INVALID_VALUE and</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwSetGamma(global::glfw3.GLFWmonitor monitor, float gamma)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            __Internal.GlfwSetGamma_0(__arg0, gamma);
        }

        // <remarks>  This function returns the current gamma ramp of the specified monitor.</remarks>
        // <param name="monitor">The monitor to query.</param>
        // <returns>
        // <para>The current gamma ramp, or `NULL` if an</para>
        // <para>[error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_lifetime The returned structure and its arrays are allocated and</para>
        // <para>freed by GLFW.  You should not free them yourself.  They are valid until the</para>
        // <para>specified monitor is disconnected, this function is called again for that</para>
        // <para>monitor or the library is terminated.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWgammaramp GlfwGetGammaRamp(global::glfw3.GLFWmonitor monitor)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            var __ret = __Internal.GlfwGetGammaRamp_0(__arg0);
            global::glfw3.GLFWgammaramp __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.GLFWgammaramp.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.GLFWgammaramp) global::glfw3.GLFWgammaramp.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.GLFWgammaramp.__CreateInstance(__ret);
            return __result0;
        }

        // <remarks>
        // <para>  This function sets the current gamma ramp for the specified monitor.  The</para>
        // <para>  original gamma ramp for that monitor is saved by GLFW the first time this</para>
        // <para>  function is called and is restored by </para>
        // </remarks>
        // <param name="monitor">The monitor whose gamma ramp to set.</param>
        // <param name="ramp">
        // <para>The gamma ramp to use.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para></para>
        // <para></para>
        // <para>_lifetime The specified gamma ramp is copied before this function</para>
        // <para>returns.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwSetGammaRamp(global::glfw3.GLFWmonitor monitor, global::glfw3.GLFWgammaramp ramp)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            var __arg1 = ReferenceEquals(ramp, null) ? global::System.IntPtr.Zero : ramp.__Instance;
            __Internal.GlfwSetGammaRamp_0(__arg0, __arg1);
        }

        // <remarks>
        // <para>  This function resets all window hints to their</para>
        // <para>  [default values](</para>
        // <para>  </para>
        // <para>Possible errors include </para>
        // <para>  </para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </remarks>
        public static void GlfwDefaultWindowHints()
        {
            __Internal.GlfwDefaultWindowHints_0();
        }

        // <remarks>
        // <para>  This function sets hints for the next call to </para>
        // <para>  hints, once set, retain their values until changed by a call to </para>
        // <para>  glfwWindowHint or </para>
        // <para>  terminated.</para>
        // <para>  This function does not check whether the specified hint values are valid.</para>
        // <para>  If you set hints to invalid values this will instead be reported by the next</para>
        // <para>  call to </para>
        // </remarks>
        // <param name="hint">The [window hint](</param>
        // <param name="value">
        // <para>The new value of the window hint.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_INVALID_ENUM.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwWindowHint(int hint, int value)
        {
            __Internal.GlfwWindowHint_0(hint, value);
        }

        // <remarks>
        // <para>  This function creates a window and its associated OpenGL or OpenGL ES</para>
        // <para>  context.  Most of the options controlling how the window and its context</para>
        // <para>  should be created are specified with [window hints](</para>
        // <para>  Successful creation does not change which context is current.  Before you</para>
        // <para>  can use the newly created context, you need to</para>
        // <para>  [make it current](</para>
        // <para>  parameter, see </para>
        // <para>  The created window, framebuffer and context may differ from what you</para>
        // <para>  requested, as not all parameters and hints are</para>
        // <para>  [hard constraints](</para>
        // <para>  window, especially for full screen windows.  To query the actual attributes</para>
        // <para>  of the created window, framebuffer and context, see </para>
        // <para>  glfwGetWindowAttrib, </para>
        // <para>  To create a full screen window, you need to specify the monitor the window</para>
        // <para>  will cover.  If no monitor is specified, the window will be windowed mode.</para>
        // <para>  Unless you have a way for the user to choose a specific monitor, it is</para>
        // <para>  recommended that you pick the primary monitor.  For more information on how</para>
        // <para>  to query connected monitors, see </para>
        // <para>  For full screen windows, the specified size becomes the resolution of the</para>
        // <para>  window's _desired video mode_.  As long as a full screen window is not</para>
        // <para>  iconified, the supported video mode most closely matching the desired video</para>
        // <para>  mode is set for the specified monitor.  For more information about full</para>
        // <para>  screen windows, including the creation of so called _windowed full screen_</para>
        // <para>  or _borderless full screen_ windows, see </para>
        // <para>  Once you have created the window, you can switch it between windowed and</para>
        // <para>  full screen mode with </para>
        // <para>  OpenGL or OpenGL ES context, it will be unaffected.</para>
        // <para>  By default, newly created windows use the placement recommended by the</para>
        // <para>  window system.  To create the window at a specific position, make it</para>
        // <para>  initially invisible using the [GLFW_VISIBLE](</para>
        // <para>  hint, set its [position](</para>
        // <para>  it.</para>
        // <para>  As long as at least one full screen window is not iconified, the screensaver</para>
        // <para>  is prohibited from starting.</para>
        // <para>  Window systems put limits on window sizes.  Very large or very small window</para>
        // <para>  dimensions may be overridden by the window system on creation.  Check the</para>
        // <para>  actual [size](</para>
        // <para>  The [swap interval](</para>
        // <para>  the initial value may vary depending on driver settings and defaults.</para>
        // </remarks>
        // <param name="width">
        // <para>The desired width, in screen coordinates, of the window.</para>
        // <para>This must be greater than zero.</para>
        // </param>
        // <param name="height">
        // <para>The desired height, in screen coordinates, of the window.</para>
        // <para>This must be greater than zero.</para>
        // </param>
        // <param name="title">The initial, UTF-8 encoded window title.</param>
        // <param name="monitor">
        // <para>The monitor to use for full screen mode, or `NULL` for</para>
        // <para>windowed mode.</para>
        // </param>
        // <param name="share">
        // <para>The window whose context to share resources with, or `NULL`</para>
        // <para>to not share resources.</para>
        // </param>
        // <returns>
        // <para>The handle of the created window, or `NULL` if an</para>
        // <para>[error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_INVALID_ENUM,</para>
        // <para>GLFW_VERSION_UNAVAILABLE,</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para></para>
        // <para></para>
        // <para></para>
        // <para></para>
        // <para></para>
        // <para></para>
        // <para></para>
        // <para></para>
        // <para>This function must not be called from a callback.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWwindow GlfwCreateWindow(int width, int height, string title, global::glfw3.GLFWmonitor monitor, global::glfw3.GLFWwindow share)
        {
            var __arg3 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            var __arg4 = ReferenceEquals(share, null) ? global::System.IntPtr.Zero : share.__Instance;
            var __ret = __Internal.GlfwCreateWindow_0(width, height, title, __arg3, __arg4);
            global::glfw3.GLFWwindow __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.GLFWwindow.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.GLFWwindow) global::glfw3.GLFWwindow.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.GLFWwindow.__CreateInstance(__ret);
            return __result0;
        }

        // <remarks>
        // <para>  This function destroys the specified window and its context.  On calling</para>
        // <para>  this function, no further callbacks will be called for that window.</para>
        // <para>  If the context of the specified window is current on the main thread, it is</para>
        // <para>  detached before being destroyed.</para>
        // </remarks>
        // <param name="window">
        // <para>The window to destroy.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para></para>
        // <para>This function must not be called from a callback.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwDestroyWindow(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwDestroyWindow_0(__arg0);
        }

        // <remarks>  This function returns the value of the close flag of the specified window.</remarks>
        // <param name="window">The window to query.</param>
        // <returns>
        // <para>The value of the close flag.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function may be called from any thread.  Access is not</para>
        // <para>synchronized.</para>
        // </returns>
        public static int GlfwWindowShouldClose(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwWindowShouldClose_0(__arg0);
            return __ret;
        }

        // <remarks>
        // <para>  This function sets the value of the close flag of the specified window.</para>
        // <para>  This can be used to override the user's attempt to close the window, or</para>
        // <para>  to signal that it should be closed.</para>
        // </remarks>
        // <param name="window">The window whose flag to change.</param>
        // <param name="value">
        // <para>The new value.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function may be called from any thread.  Access is not</para>
        // <para>synchronized.</para>
        // </param>
        public static void GlfwSetWindowShouldClose(global::glfw3.GLFWwindow window, int value)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowShouldClose_0(__arg0, value);
        }

        // <remarks>
        // <para>  This function sets the window title, encoded as UTF-8, of the specified</para>
        // <para>  window.</para>
        // </remarks>
        // <param name="window">The window whose title to change.</param>
        // <param name="title">
        // <para>The UTF-8 encoded window title.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwSetWindowTitle(global::glfw3.GLFWwindow window, string title)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowTitle_0(__arg0, title);
        }

        // <remarks>
        // <para>  This function sets the icon of the specified window.  If passed an array of</para>
        // <para>  candidate images, those of or closest to the sizes desired by the system are</para>
        // <para>  selected.  If no images are specified, the window reverts to its default</para>
        // <para>  icon.</para>
        // <para>  The desired image sizes varies depending on platform and system settings.</para>
        // <para>  The selected images will be rescaled as needed.  Good sizes include 16x16,</para>
        // <para>  32x32 and 48x48.</para>
        // </remarks>
        // <param name="window">The window whose icon to set.</param>
        // <param name="count">
        // <para>The number of images in the specified array, or zero to</para>
        // <para>revert to the default window icon.</para>
        // </param>
        // <param name="images">
        // <para>The images to create the icon from.  This is ignored if</para>
        // <para>count is zero.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_lifetime The specified image data is copied before this function</para>
        // <para>returns.</para>
        // <para></para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwSetWindowIcon(global::glfw3.GLFWwindow window, int count, global::glfw3.GLFWimage images)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg2 = ReferenceEquals(images, null) ? global::System.IntPtr.Zero : images.__Instance;
            __Internal.GlfwSetWindowIcon_0(__arg0, count, __arg2);
        }

        // <remarks>
        // <para>  This function retrieves the position, in screen coordinates, of the</para>
        // <para>  upper-left corner of the client area of the specified window.</para>
        // <para>  Any or all of the position arguments may be `NULL`.  If an error occurs, all</para>
        // <para>  non-`NULL` position arguments will be set to zero.</para>
        // </remarks>
        // <param name="window">The window to query.</param>
        // <param name="xpos">
        // <para>Where to store the x-coordinate of the upper-left corner of</para>
        // <para>the client area, or `NULL`.</para>
        // </param>
        // <param name="ypos">
        // <para>Where to store the y-coordinate of the upper-left corner of</para>
        // <para>the client area, or `NULL`.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwGetWindowPos(global::glfw3.GLFWwindow window, ref int xpos, ref int ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __refParamPtr1 = &xpos)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &ypos)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GlfwGetWindowPos_0(__arg0, __arg1, __arg2);
                }
            }
        }

        // <remarks>
        // <para>  This function sets the position, in screen coordinates, of the upper-left</para>
        // <para>  corner of the client area of the specified windowed mode window.  If the</para>
        // <para>  window is a full screen window, this function does nothing.</para>
        // <para>  __Do not use this function__ to move an already visible window unless you</para>
        // <para>  have very good reasons for doing so, as it will confuse and annoy the user.</para>
        // <para>  The window manager may put limits on what positions are allowed.  GLFW</para>
        // <para>  cannot and should not override these limits.</para>
        // </remarks>
        // <param name="window">The window to query.</param>
        // <param name="xpos">The x-coordinate of the upper-left corner of the client area.</param>
        // <param name="ypos">
        // <para>The y-coordinate of the upper-left corner of the client area.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwSetWindowPos(global::glfw3.GLFWwindow window, int xpos, int ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowPos_0(__arg0, xpos, ypos);
        }

        // <remarks>
        // <para>  This function retrieves the size, in screen coordinates, of the client area</para>
        // <para>  of the specified window.  If you wish to retrieve the size of the</para>
        // <para>  framebuffer of the window in pixels, see </para>
        // <para>  Any or all of the size arguments may be `NULL`.  If an error occurs, all</para>
        // <para>  non-`NULL` size arguments will be set to zero.</para>
        // </remarks>
        // <param name="window">The window whose size to retrieve.</param>
        // <param name="width">
        // <para>Where to store the width, in screen coordinates, of the</para>
        // <para>client area, or `NULL`.</para>
        // </param>
        // <param name="height">
        // <para>Where to store the height, in screen coordinates, of the</para>
        // <para>client area, or `NULL`.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwGetWindowSize(global::glfw3.GLFWwindow window, ref int width, ref int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __refParamPtr1 = &width)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &height)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GlfwGetWindowSize_0(__arg0, __arg1, __arg2);
                }
            }
        }

        // <remarks>
        // <para>  This function sets the size limits of the client area of the specified</para>
        // <para>  window.  If the window is full screen, the size limits only take effect</para>
        // <para>  once it is made windowed.  If the window is not resizable, this function</para>
        // <para>  does nothing.</para>
        // <para>  The size limits are applied immediately to a windowed mode window and may</para>
        // <para>  cause it to be resized.</para>
        // <para>  The maximum dimensions must be greater than or equal to the minimum</para>
        // <para>  dimensions and all must be greater than or equal to zero.</para>
        // </remarks>
        // <param name="window">The window to set limits for.</param>
        // <param name="minwidth">
        // <para>The minimum width, in screen coordinates, of the client</para>
        // <para>area, or `GLFW_DONT_CARE`.</para>
        // </param>
        // <param name="minheight">
        // <para>The minimum height, in screen coordinates, of the</para>
        // <para>client area, or `GLFW_DONT_CARE`.</para>
        // </param>
        // <param name="maxwidth">
        // <para>The maximum width, in screen coordinates, of the client</para>
        // <para>area, or `GLFW_DONT_CARE`.</para>
        // </param>
        // <param name="maxheight">
        // <para>The maximum height, in screen coordinates, of the</para>
        // <para>client area, or `GLFW_DONT_CARE`.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_INVALID_VALUE and</para>
        // <para></para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwSetWindowSizeLimits(global::glfw3.GLFWwindow window, int minwidth, int minheight, int maxwidth, int maxheight)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowSizeLimits_0(__arg0, minwidth, minheight, maxwidth, maxheight);
        }

        // <remarks>
        // <para>  This function sets the required aspect ratio of the client area of the</para>
        // <para>  specified window.  If the window is full screen, the aspect ratio only takes</para>
        // <para>  effect once it is made windowed.  If the window is not resizable, this</para>
        // <para>  function does nothing.</para>
        // <para>  The aspect ratio is specified as a numerator and a denominator and both</para>
        // <para>  values must be greater than zero.  For example, the common 16:9 aspect ratio</para>
        // <para>  is specified as 16 and 9, respectively.</para>
        // <para>  If the numerator and denominator is set to `GLFW_DONT_CARE` then the aspect</para>
        // <para>  ratio limit is disabled.</para>
        // <para>  The aspect ratio is applied immediately to a windowed mode window and may</para>
        // <para>  cause it to be resized.</para>
        // </remarks>
        // <param name="window">The window to set limits for.</param>
        // <param name="numer">
        // <para>The numerator of the desired aspect ratio, or</para>
        // <para>`GLFW_DONT_CARE`.</para>
        // </param>
        // <param name="denom">
        // <para>The denominator of the desired aspect ratio, or</para>
        // <para>`GLFW_DONT_CARE`.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_INVALID_VALUE and</para>
        // <para></para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwSetWindowAspectRatio(global::glfw3.GLFWwindow window, int numer, int denom)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowAspectRatio_0(__arg0, numer, denom);
        }

        // <remarks>
        // <para>  This function sets the size, in screen coordinates, of the client area of</para>
        // <para>  the specified window.</para>
        // <para>  For full screen windows, this function updates the resolution of its desired</para>
        // <para>  video mode and switches to the video mode closest to it, without affecting</para>
        // <para>  the window's context.  As the context is unaffected, the bit depths of the</para>
        // <para>  framebuffer remain unchanged.</para>
        // <para>  If you wish to update the refresh rate of the desired video mode in addition</para>
        // <para>  to its resolution, see </para>
        // <para>  The window manager may put limits on what sizes are allowed.  GLFW cannot</para>
        // <para>  and should not override these limits.</para>
        // </remarks>
        // <param name="window">The window to resize.</param>
        // <param name="width">
        // <para>The desired width, in screen coordinates, of the window</para>
        // <para>client area.</para>
        // </param>
        // <param name="height">
        // <para>The desired height, in screen coordinates, of the window</para>
        // <para>client area.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwSetWindowSize(global::glfw3.GLFWwindow window, int width, int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowSize_0(__arg0, width, height);
        }

        // <remarks>
        // <para>  This function retrieves the size, in pixels, of the framebuffer of the</para>
        // <para>  specified window.  If you wish to retrieve the size of the window in screen</para>
        // <para>  coordinates, see </para>
        // <para>  Any or all of the size arguments may be `NULL`.  If an error occurs, all</para>
        // <para>  non-`NULL` size arguments will be set to zero.</para>
        // </remarks>
        // <param name="window">The window whose framebuffer to query.</param>
        // <param name="width">
        // <para>Where to store the width, in pixels, of the framebuffer,</para>
        // <para>or `NULL`.</para>
        // </param>
        // <param name="height">
        // <para>Where to store the height, in pixels, of the framebuffer,</para>
        // <para>or `NULL`.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwGetFramebufferSize(global::glfw3.GLFWwindow window, ref int width, ref int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __refParamPtr1 = &width)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &height)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GlfwGetFramebufferSize_0(__arg0, __arg1, __arg2);
                }
            }
        }

        // <remarks>
        // <para>  This function retrieves the size, in screen coordinates, of each edge of the</para>
        // <para>  frame of the specified window.  This size includes the title bar, if the</para>
        // <para>  window has one.  The size of the frame may vary depending on the</para>
        // <para>  [window-related hints](</para>
        // <para>  Because this function retrieves the size of each window frame edge and not</para>
        // <para>  the offset along a particular coordinate axis, the retrieved values will</para>
        // <para>  always be zero or positive.</para>
        // <para>  Any or all of the size arguments may be `NULL`.  If an error occurs, all</para>
        // <para>  non-`NULL` size arguments will be set to zero.</para>
        // </remarks>
        // <param name="window">The window whose frame size to query.</param>
        // <param name="left">
        // <para>Where to store the size, in screen coordinates, of the left</para>
        // <para>edge of the window frame, or `NULL`.</para>
        // </param>
        // <param name="top">
        // <para>Where to store the size, in screen coordinates, of the top</para>
        // <para>edge of the window frame, or `NULL`.</para>
        // </param>
        // <param name="right">
        // <para>Where to store the size, in screen coordinates, of the</para>
        // <para>right edge of the window frame, or `NULL`.</para>
        // </param>
        // <param name="bottom">
        // <para>Where to store the size, in screen coordinates, of the</para>
        // <para>bottom edge of the window frame, or `NULL`.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwGetWindowFrameSize(global::glfw3.GLFWwindow window, ref int left, ref int top, ref int right, ref int bottom)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __refParamPtr1 = &left)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &top)
                {
                    var __arg2 = __refParamPtr2;
                    fixed (int* __refParamPtr3 = &right)
                    {
                        var __arg3 = __refParamPtr3;
                        fixed (int* __refParamPtr4 = &bottom)
                        {
                            var __arg4 = __refParamPtr4;
                            __Internal.GlfwGetWindowFrameSize_0(__arg0, __arg1, __arg2, __arg3, __arg4);
                        }
                    }
                }
            }
        }

        // <remarks>
        // <para>  This function iconifies (minimizes) the specified window if it was</para>
        // <para>  previously restored.  If the window is already iconified, this function does</para>
        // <para>  nothing.</para>
        // <para>  If the specified window is a full screen window, the original monitor</para>
        // <para>  resolution is restored until the window is restored.</para>
        // </remarks>
        // <param name="window">
        // <para>The window to iconify.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwIconifyWindow(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwIconifyWindow_0(__arg0);
        }

        // <remarks>
        // <para>  This function restores the specified window if it was previously iconified</para>
        // <para>  (minimized) or maximized.  If the window is already restored, this function</para>
        // <para>  does nothing.</para>
        // <para>  If the specified window is a full screen window, the resolution chosen for</para>
        // <para>  the window is restored on the selected monitor.</para>
        // </remarks>
        // <param name="window">
        // <para>The window to restore.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwRestoreWindow(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwRestoreWindow_0(__arg0);
        }

        // <remarks>
        // <para>  This function maximizes the specified window if it was previously not</para>
        // <para>  maximized.  If the window is already maximized, this function does nothing.</para>
        // <para>  If the specified window is a full screen window, this function does nothing.</para>
        // </remarks>
        // <param name="window">
        // <para>The window to maximize.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // </param>
        public static void GlfwMaximizeWindow(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwMaximizeWindow_0(__arg0);
        }

        // <remarks>
        // <para>  This function makes the specified window visible if it was previously</para>
        // <para>  hidden.  If the window is already visible or is in full screen mode, this</para>
        // <para>  function does nothing.</para>
        // </remarks>
        // <param name="window">
        // <para>The window to make visible.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwShowWindow(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwShowWindow_0(__arg0);
        }

        // <remarks>
        // <para>  This function hides the specified window if it was previously visible.  If</para>
        // <para>  the window is already hidden or is in full screen mode, this function does</para>
        // <para>  nothing.</para>
        // </remarks>
        // <param name="window">
        // <para>The window to hide.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwHideWindow(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwHideWindow_0(__arg0);
        }

        // <remarks>
        // <para>  This function brings the specified window to front and sets input focus.</para>
        // <para>  The window should already be visible and not iconified.</para>
        // <para>  By default, both windowed and full screen mode windows are focused when</para>
        // <para>  initially created.  Set the [GLFW_FOCUSED](</para>
        // <para>  this behavior.</para>
        // <para>  __Do not use this function__ to steal focus from other applications unless</para>
        // <para>  you are certain that is what the user wants.  Focus stealing can be</para>
        // <para>  extremely disruptive.</para>
        // </remarks>
        // <param name="window">
        // <para>The window to give input focus.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwFocusWindow(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwFocusWindow_0(__arg0);
        }

        // <remarks>
        // <para>  This function returns the handle of the monitor that the specified window is</para>
        // <para>  in full screen on.</para>
        // </remarks>
        // <param name="window">The window to query.</param>
        // <returns>
        // <para>The monitor, or `NULL` if the window is in windowed mode or an</para>
        // <para>[error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWmonitor GlfwGetWindowMonitor(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetWindowMonitor_0(__arg0);
            global::glfw3.GLFWmonitor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.GLFWmonitor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.GLFWmonitor) global::glfw3.GLFWmonitor.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.GLFWmonitor.__CreateInstance(__ret);
            return __result0;
        }

        // <remarks>
        // <para>  This function sets the monitor that the window uses for full screen mode or,</para>
        // <para>  if the monitor is `NULL`, makes it windowed mode.</para>
        // <para>  When setting a monitor, this function updates the width, height and refresh</para>
        // <para>  rate of the desired video mode and switches to the video mode closest to it.</para>
        // <para>  The window position is ignored when setting a monitor.</para>
        // <para>  When the monitor is `NULL`, the position, width and height are used to</para>
        // <para>  place the window client area.  The refresh rate is ignored when no monitor</para>
        // <para>  is specified.</para>
        // <para>  If you only wish to update the resolution of a full screen window or the</para>
        // <para>  size of a windowed mode window, see </para>
        // <para>  When a window transitions from full screen to windowed mode, this function</para>
        // <para>  restores any previous window settings such as whether it is decorated,</para>
        // <para>  floating, resizable, has size or aspect ratio limits, etc..</para>
        // </remarks>
        // <param name="window">The window whose monitor, size or video mode to set.</param>
        // <param name="monitor">The desired monitor, or `NULL` to set windowed mode.</param>
        // <param name="xpos">
        // <para>The desired x-coordinate of the upper-left corner of the</para>
        // <para>client area.</para>
        // </param>
        // <param name="ypos">
        // <para>The desired y-coordinate of the upper-left corner of the</para>
        // <para>client area.</para>
        // </param>
        // <param name="width">
        // <para>The desired with, in screen coordinates, of the client area</para>
        // <para>or video mode.</para>
        // </param>
        // <param name="height">
        // <para>The desired height, in screen coordinates, of the client</para>
        // <para>area or video mode.</para>
        // </param>
        // <param name="refreshRate">
        // <para>The desired refresh rate, in Hz, of the video mode,</para>
        // <para>or `GLFW_DONT_CARE`.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwSetWindowMonitor(global::glfw3.GLFWwindow window, global::glfw3.GLFWmonitor monitor, int xpos, int ypos, int width, int height, int refreshRate)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            __Internal.GlfwSetWindowMonitor_0(__arg0, __arg1, xpos, ypos, width, height, refreshRate);
        }

        // <remarks>
        // <para>  This function returns the value of an attribute of the specified window or</para>
        // <para>  its OpenGL or OpenGL ES context.</para>
        // </remarks>
        // <param name="window">The window to query.</param>
        // <param name="attrib">
        // <para>The [window attribute](</para>
        // <para>return.</para>
        // </param>
        // <returns>
        // <para>The value of the attribute, or zero if an</para>
        // <para>[error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_INVALID_ENUM and</para>
        // <para></para>
        // <para>window_attribs_fb for more information.</para>
        // <para></para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static int GlfwGetWindowAttrib(global::glfw3.GLFWwindow window, int attrib)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetWindowAttrib_0(__arg0, attrib);
            return __ret;
        }

        // <remarks>
        // <para>  This function sets the user-defined pointer of the specified window.  The</para>
        // <para>  current value is retained until the window is destroyed.  The initial value</para>
        // <para>  is `NULL`.</para>
        // </remarks>
        // <param name="window">The window whose pointer to set.</param>
        // <param name="pointer">
        // <para>The new value.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function may be called from any thread.  Access is not</para>
        // <para>synchronized.</para>
        // </param>
        public static void GlfwSetWindowUserPointer(global::glfw3.GLFWwindow window, global::System.IntPtr pointer)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowUserPointer_0(__arg0, pointer);
        }

        // <remarks>
        // <para>  This function returns the current value of the user-defined pointer of the</para>
        // <para>  specified window.  The initial value is `NULL`.</para>
        // </remarks>
        // <param name="window">
        // <para>The window whose pointer to return.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function may be called from any thread.  Access is not</para>
        // <para>synchronized.</para>
        // </param>
        public static global::System.IntPtr GlfwGetWindowUserPointer(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetWindowUserPointer_0(__arg0);
            return __ret;
        }

        // <remarks>
        // <para>  This function sets the position callback of the specified window, which is</para>
        // <para>  called when the window is moved.  The callback is provided with the screen</para>
        // <para>  position of the upper-left corner of the client area of the window.</para>
        // </remarks>
        // <param name="window">The window whose callback to set.</param>
        // <param name="cbfun">
        // <para>The new callback, or `NULL` to remove the currently set</para>
        // <para>callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set or the</para>
        // <para>library had not been [initialized](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWwindowposfun GlfwSetWindowPosCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWwindowposfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetWindowPosCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWwindowposfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWwindowposfun));
        }

        // <remarks>
        // <para>  This function sets the size callback of the specified window, which is</para>
        // <para>  called when the window is resized.  The callback is provided with the size,</para>
        // <para>  in screen coordinates, of the client area of the window.</para>
        // </remarks>
        // <param name="window">The window whose callback to set.</param>
        // <param name="cbfun">
        // <para>The new callback, or `NULL` to remove the currently set</para>
        // <para>callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set or the</para>
        // <para>library had not been [initialized](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWwindowsizefun GlfwSetWindowSizeCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWwindowsizefun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetWindowSizeCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWwindowsizefun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWwindowsizefun));
        }

        // <remarks>
        // <para>  This function sets the close callback of the specified window, which is</para>
        // <para>  called when the user attempts to close the window, for example by clicking</para>
        // <para>  the close widget in the title bar.</para>
        // <para>  The close flag is set before this callback is called, but you can modify it</para>
        // <para>  at any time with </para>
        // <para>  The close callback is not triggered by </para>
        // </remarks>
        // <param name="window">The window whose callback to set.</param>
        // <param name="cbfun">
        // <para>The new callback, or `NULL` to remove the currently set</para>
        // <para>callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set or the</para>
        // <para>library had not been [initialized](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWwindowclosefun GlfwSetWindowCloseCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWwindowclosefun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetWindowCloseCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWwindowclosefun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWwindowclosefun));
        }

        // <remarks>
        // <para>  This function sets the refresh callback of the specified window, which is</para>
        // <para>  called when the client area of the window needs to be redrawn, for example</para>
        // <para>  if the window has been exposed after having been covered by another window.</para>
        // <para>  On compositing window systems such as Aero, Compiz or Aqua, where the window</para>
        // <para>  contents are saved off-screen, this callback may be called only very</para>
        // <para>  infrequently or never at all.</para>
        // </remarks>
        // <param name="window">The window whose callback to set.</param>
        // <param name="cbfun">
        // <para>The new callback, or `NULL` to remove the currently set</para>
        // <para>callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set or the</para>
        // <para>library had not been [initialized](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWwindowrefreshfun GlfwSetWindowRefreshCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWwindowrefreshfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetWindowRefreshCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWwindowrefreshfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWwindowrefreshfun));
        }

        // <remarks>
        // <para>  This function sets the focus callback of the specified window, which is</para>
        // <para>  called when the window gains or loses input focus.</para>
        // <para>  After the focus callback is called for a window that lost input focus,</para>
        // <para>  synthetic key and mouse button release events will be generated for all such</para>
        // <para>  that had been pressed.  For more information, see </para>
        // <para>  and </para>
        // </remarks>
        // <param name="window">The window whose callback to set.</param>
        // <param name="cbfun">
        // <para>The new callback, or `NULL` to remove the currently set</para>
        // <para>callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set or the</para>
        // <para>library had not been [initialized](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWwindowfocusfun GlfwSetWindowFocusCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWwindowfocusfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetWindowFocusCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWwindowfocusfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWwindowfocusfun));
        }

        // <remarks>
        // <para>  This function sets the iconification callback of the specified window, which</para>
        // <para>  is called when the window is iconified or restored.</para>
        // </remarks>
        // <param name="window">The window whose callback to set.</param>
        // <param name="cbfun">
        // <para>The new callback, or `NULL` to remove the currently set</para>
        // <para>callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set or the</para>
        // <para>library had not been [initialized](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWwindowiconifyfun GlfwSetWindowIconifyCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWwindowiconifyfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetWindowIconifyCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWwindowiconifyfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWwindowiconifyfun));
        }

        // <remarks>
        // <para>  This function sets the framebuffer resize callback of the specified window,</para>
        // <para>  which is called when the framebuffer of the specified window is resized.</para>
        // </remarks>
        // <param name="window">The window whose callback to set.</param>
        // <param name="cbfun">
        // <para>The new callback, or `NULL` to remove the currently set</para>
        // <para>callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set or the</para>
        // <para>library had not been [initialized](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWframebuffersizefun GlfwSetFramebufferSizeCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWframebuffersizefun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetFramebufferSizeCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWframebuffersizefun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWframebuffersizefun));
        }

        // <remarks>
        // <para>  This function processes only those events that are already in the event</para>
        // <para>  queue and then returns immediately.  Processing events will cause the window</para>
        // <para>  and input callbacks associated with those events to be called.</para>
        // <para>  On some platforms, a window move, resize or menu operation will cause event</para>
        // <para>  processing to block.  This is due to how event processing is designed on</para>
        // <para>  those platforms.  You can use the</para>
        // <para>  [window refresh callback](</para>
        // <para>  your window when necessary during such operations.</para>
        // <para>  On some platforms, certain events are sent directly to the application</para>
        // <para>  without going through the event queue, causing callbacks to be called</para>
        // <para>  outside of a call to one of the event processing functions.</para>
        // <para>  Event processing is not required for joystick input to work.</para>
        // <para>  </para>
        // <para>Possible errors include </para>
        // <para>  GLFW_PLATFORM_ERROR.</para>
        // <para>  </para>
        // <para>This function must not be called from a callback.</para>
        // <para>  </para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </remarks>
        public static void GlfwPollEvents()
        {
            __Internal.GlfwPollEvents_0();
        }

        // <remarks>
        // <para>  This function puts the calling thread to sleep until at least one event is</para>
        // <para>  available in the event queue.  Once one or more events are available,</para>
        // <para>  it behaves exactly like </para>
        // <para>  are processed and the function then returns immediately.  Processing events</para>
        // <para>  will cause the window and input callbacks associated with those events to be</para>
        // <para>  called.</para>
        // <para>  Since not all events are associated with callbacks, this function may return</para>
        // <para>  without a callback having been called even if you are monitoring all</para>
        // <para>  callbacks.</para>
        // <para>  On some platforms, a window move, resize or menu operation will cause event</para>
        // <para>  processing to block.  This is due to how event processing is designed on</para>
        // <para>  those platforms.  You can use the</para>
        // <para>  [window refresh callback](</para>
        // <para>  your window when necessary during such operations.</para>
        // <para>  On some platforms, certain callbacks may be called outside of a call to one</para>
        // <para>  of the event processing functions.</para>
        // <para>  If no windows exist, this function returns immediately.  For synchronization</para>
        // <para>  of threads in applications that do not create windows, use your threading</para>
        // <para>  library of choice.</para>
        // <para>  Event processing is not required for joystick input to work.</para>
        // <para>  </para>
        // <para>Possible errors include </para>
        // <para>  GLFW_PLATFORM_ERROR.</para>
        // <para>  </para>
        // <para>This function must not be called from a callback.</para>
        // <para>  </para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </remarks>
        public static void GlfwWaitEvents()
        {
            __Internal.GlfwWaitEvents_0();
        }

        // <remarks>
        // <para>  This function puts the calling thread to sleep until at least one event is</para>
        // <para>  available in the event queue, or until the specified timeout is reached.  If</para>
        // <para>  one or more events are available, it behaves exactly like </para>
        // <para>  glfwPollEvents, i.e. the events in the queue are processed and the function</para>
        // <para>  then returns immediately.  Processing events will cause the window and input</para>
        // <para>  callbacks associated with those events to be called.</para>
        // <para>  The timeout value must be a positive finite number.</para>
        // <para>  Since not all events are associated with callbacks, this function may return</para>
        // <para>  without a callback having been called even if you are monitoring all</para>
        // <para>  callbacks.</para>
        // <para>  On some platforms, a window move, resize or menu operation will cause event</para>
        // <para>  processing to block.  This is due to how event processing is designed on</para>
        // <para>  those platforms.  You can use the</para>
        // <para>  [window refresh callback](</para>
        // <para>  your window when necessary during such operations.</para>
        // <para>  On some platforms, certain callbacks may be called outside of a call to one</para>
        // <para>  of the event processing functions.</para>
        // <para>  If no windows exist, this function returns immediately.  For synchronization</para>
        // <para>  of threads in applications that do not create windows, use your threading</para>
        // <para>  library of choice.</para>
        // <para>  Event processing is not required for joystick input to work.</para>
        // </remarks>
        // <param name="timeout">
        // <para>The maximum amount of time, in seconds, to wait.</para>
        // <para></para>
        // <para>This function must not be called from a callback.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwWaitEventsTimeout(double timeout)
        {
            __Internal.GlfwWaitEventsTimeout_0(timeout);
        }

        // <remarks>
        // <para>  This function posts an empty event from the current thread to the event</para>
        // <para>  queue, causing </para>
        // <para>  If no windows exist, this function returns immediately.  For synchronization</para>
        // <para>  of threads in applications that do not create windows, use your threading</para>
        // <para>  library of choice.</para>
        // <para>  </para>
        // <para>Possible errors include </para>
        // <para>  GLFW_PLATFORM_ERROR.</para>
        // <para>  </para>
        // <para>_safety This function may be called from any thread.</para>
        // </remarks>
        public static void GlfwPostEmptyEvent()
        {
            __Internal.GlfwPostEmptyEvent_0();
        }

        // <remarks>
        // <para>  This function returns the value of an input option for the specified window.</para>
        // <para>  The mode must be one of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or</para>
        // <para>  `GLFW_STICKY_MOUSE_BUTTONS`.</para>
        // </remarks>
        // <param name="window">The window to query.</param>
        // <param name="mode">
        // <para>One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or</para>
        // <para>`GLFW_STICKY_MOUSE_BUTTONS`.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_INVALID_ENUM.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static int GlfwGetInputMode(global::glfw3.GLFWwindow window, int mode)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetInputMode_0(__arg0, mode);
            return __ret;
        }

        // <remarks>
        // <para>  This function sets an input mode option for the specified window.  The mode</para>
        // <para>  must be one of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or</para>
        // <para>  `GLFW_STICKY_MOUSE_BUTTONS`.</para>
        // <para>  If the mode is `GLFW_CURSOR`, the value must be one of the following cursor</para>
        // <para>  modes:</para>
        // <para>  - `GLFW_CURSOR_NORMAL` makes the cursor visible and behaving normally.</para>
        // <para>  - `GLFW_CURSOR_HIDDEN` makes the cursor invisible when it is over the client</para>
        // <para>    area of the window but does not restrict the cursor from leaving.</para>
        // <para>  - `GLFW_CURSOR_DISABLED` hides and grabs the cursor, providing virtual</para>
        // <para>    and unlimited cursor movement.  This is useful for implementing for</para>
        // <para>    example 3D camera controls.</para>
        // <para>  If the mode is `GLFW_STICKY_KEYS`, the value must be either `GLFW_TRUE` to</para>
        // <para>  enable sticky keys, or `GLFW_FALSE` to disable it.  If sticky keys are</para>
        // <para>  enabled, a key press will ensure that </para>
        // <para>  the next time it is called even if the key had been released before the</para>
        // <para>  call.  This is useful when you are only interested in whether keys have been</para>
        // <para>  pressed but not when or in which order.</para>
        // <para>  If the mode is `GLFW_STICKY_MOUSE_BUTTONS`, the value must be either</para>
        // <para>  `GLFW_TRUE` to enable sticky mouse buttons, or `GLFW_FALSE` to disable it.</para>
        // <para>  If sticky mouse buttons are enabled, a mouse button press will ensure that</para>
        // <para>  </para>
        // <para>  if the mouse button had been released before the call.  This is useful when</para>
        // <para>  you are only interested in whether mouse buttons have been pressed but not</para>
        // <para>  when or in which order.</para>
        // </remarks>
        // <param name="window">The window whose input mode to set.</param>
        // <param name="mode">
        // <para>One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or</para>
        // <para>`GLFW_STICKY_MOUSE_BUTTONS`.</para>
        // </param>
        // <param name="value">
        // <para>The new value of the specified input mode.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_INVALID_ENUM and</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwSetInputMode(global::glfw3.GLFWwindow window, int mode, int value)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetInputMode_0(__arg0, mode, value);
        }

        // <remarks>
        // <para>  This function returns the localized name of the specified printable key.</para>
        // <para>  This is intended for displaying key bindings to the user.</para>
        // <para>  If the key is `GLFW_KEY_UNKNOWN`, the scancode is used instead, otherwise</para>
        // <para>  the scancode is ignored.  If a non-printable key or (if the key is</para>
        // <para>  `GLFW_KEY_UNKNOWN`) a scancode that maps to a non-printable key is</para>
        // <para>  specified, this function returns `NULL`.          </para>
        // <para>  This behavior allows you to pass in the arguments passed to the</para>
        // <para>  [key callback](</para>
        // <para>  The printable keys are:</para>
        // <para>  - `GLFW_KEY_APOSTROPHE`</para>
        // <para>  - `GLFW_KEY_COMMA`</para>
        // <para>  - `GLFW_KEY_MINUS`</para>
        // <para>  - `GLFW_KEY_PERIOD`</para>
        // <para>  - `GLFW_KEY_SLASH`</para>
        // <para>  - `GLFW_KEY_SEMICOLON`</para>
        // <para>  - `GLFW_KEY_EQUAL`</para>
        // <para>  - `GLFW_KEY_LEFT_BRACKET`</para>
        // <para>  - `GLFW_KEY_RIGHT_BRACKET`</para>
        // <para>  - `GLFW_KEY_BACKSLASH`</para>
        // <para>  - `GLFW_KEY_WORLD_1`</para>
        // <para>  - `GLFW_KEY_WORLD_2`</para>
        // <para>  - `GLFW_KEY_0` to `GLFW_KEY_9`</para>
        // <para>  - `GLFW_KEY_A` to `GLFW_KEY_Z`</para>
        // <para>  - `GLFW_KEY_KP_0` to `GLFW_KEY_KP_9`</para>
        // <para>  - `GLFW_KEY_KP_DECIMAL`</para>
        // <para>  - `GLFW_KEY_KP_DIVIDE`</para>
        // <para>  - `GLFW_KEY_KP_MULTIPLY`</para>
        // <para>  - `GLFW_KEY_KP_SUBTRACT`</para>
        // <para>  - `GLFW_KEY_KP_ADD`</para>
        // <para>  - `GLFW_KEY_KP_EQUAL`</para>
        // </remarks>
        // <param name="key">The key to query, or `GLFW_KEY_UNKNOWN`.</param>
        // <param name="scancode">The scancode of the key to query.</param>
        // <returns>
        // <para>The localized name of the key, or `NULL`.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_lifetime The returned string is allocated and freed by GLFW.  You</para>
        // <para>should not free it yourself.  It is valid until the next call to</para>
        // <para>glfwGetKeyName, or until the library is terminated.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static string GlfwGetKeyName(int key, int scancode)
        {
            var __ret = __Internal.GlfwGetKeyName_0(key, scancode);
            return Marshal.PtrToStringAnsi(__ret);
        }

        // <remarks>
        // <para>  This function returns the last state reported for the specified key to the</para>
        // <para>  specified window.  The returned state is one of `GLFW_PRESS` or</para>
        // <para>  `GLFW_RELEASE`.  The higher-level action `GLFW_REPEAT` is only reported to</para>
        // <para>  the key callback.</para>
        // <para>  If the `GLFW_STICKY_KEYS` input mode is enabled, this function returns</para>
        // <para>  `GLFW_PRESS` the first time you call it for a key that was pressed, even if</para>
        // <para>  that key has already been released.</para>
        // <para>  The key functions deal with physical keys, with [key tokens](</para>
        // <para>  named after their use on the standard US keyboard layout.  If you want to</para>
        // <para>  input text, use the Unicode character callback instead.</para>
        // <para>  The [modifier key bit masks](</para>
        // <para>  used with this function.</para>
        // <para>  __Do not use this function__ to implement [text input](</para>
        // </remarks>
        // <param name="window">The desired window.</param>
        // <param name="key">
        // <para>The desired [keyboard key](</para>
        // <para>not a valid key for this function.</para>
        // </param>
        // <returns>
        // <para>One of `GLFW_PRESS` or `GLFW_RELEASE`.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_INVALID_ENUM.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static int GlfwGetKey(global::glfw3.GLFWwindow window, int key)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetKey_0(__arg0, key);
            return __ret;
        }

        // <remarks>
        // <para>  This function returns the last state reported for the specified mouse button</para>
        // <para>  to the specified window.  The returned state is one of `GLFW_PRESS` or</para>
        // <para>  `GLFW_RELEASE`.</para>
        // <para>  If the `GLFW_STICKY_MOUSE_BUTTONS` input mode is enabled, this function</para>
        // <para>  `GLFW_PRESS` the first time you call it for a mouse button that was pressed,</para>
        // <para>  even if that mouse button has already been released.</para>
        // </remarks>
        // <param name="window">The desired window.</param>
        // <param name="button">The desired [mouse button](</param>
        // <returns>
        // <para>One of `GLFW_PRESS` or `GLFW_RELEASE`.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_INVALID_ENUM.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static int GlfwGetMouseButton(global::glfw3.GLFWwindow window, int button)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetMouseButton_0(__arg0, button);
            return __ret;
        }

        // <remarks>
        // <para>  This function returns the position of the cursor, in screen coordinates,</para>
        // <para>  relative to the upper-left corner of the client area of the specified</para>
        // <para>  window.</para>
        // <para>  If the cursor is disabled (with `GLFW_CURSOR_DISABLED`) then the cursor</para>
        // <para>  position is unbounded and limited only by the minimum and maximum values of</para>
        // <para>  a `double`.</para>
        // <para>  The coordinate can be converted to their integer equivalents with the</para>
        // <para>  `floor` function.  Casting directly to an integer type works for positive</para>
        // <para>  coordinates, but fails for negative ones.</para>
        // <para>  Any or all of the position arguments may be `NULL`.  If an error occurs, all</para>
        // <para>  non-`NULL` position arguments will be set to zero.</para>
        // </remarks>
        // <param name="window">The desired window.</param>
        // <param name="xpos">
        // <para>Where to store the cursor x-coordinate, relative to the</para>
        // <para>left edge of the client area, or `NULL`.</para>
        // </param>
        // <param name="ypos">
        // <para>Where to store the cursor y-coordinate, relative to the to</para>
        // <para>top edge of the client area, or `NULL`.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwGetCursorPos(global::glfw3.GLFWwindow window, ref double xpos, ref double ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (double* __refParamPtr1 = &xpos)
            {
                var __arg1 = __refParamPtr1;
                fixed (double* __refParamPtr2 = &ypos)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GlfwGetCursorPos_0(__arg0, __arg1, __arg2);
                }
            }
        }

        // <remarks>
        // <para>  This function sets the position, in screen coordinates, of the cursor</para>
        // <para>  relative to the upper-left corner of the client area of the specified</para>
        // <para>  window.  The window must have input focus.  If the window does not have</para>
        // <para>  input focus when this function is called, it fails silently.</para>
        // <para>  __Do not use this function__ to implement things like camera controls.  GLFW</para>
        // <para>  already provides the `GLFW_CURSOR_DISABLED` cursor mode that hides the</para>
        // <para>  cursor, transparently re-centers it and provides unconstrained cursor</para>
        // <para>  motion.  See </para>
        // <para>  If the cursor mode is `GLFW_CURSOR_DISABLED` then the cursor position is</para>
        // <para>  unconstrained and limited only by the minimum and maximum values of</para>
        // <para>  a `double`.</para>
        // </remarks>
        // <param name="window">The desired window.</param>
        // <param name="xpos">
        // <para>The desired x-coordinate, relative to the left edge of the</para>
        // <para>client area.</para>
        // </param>
        // <param name="ypos">
        // <para>The desired y-coordinate, relative to the top edge of the</para>
        // <para>client area.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwSetCursorPos(global::glfw3.GLFWwindow window, double xpos, double ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetCursorPos_0(__arg0, xpos, ypos);
        }

        // <remarks>
        // <para>  Creates a new custom cursor image that can be set for a window with </para>
        // <para>  glfwSetCursor.  The cursor can be destroyed with </para>
        // <para>  Any remaining cursors are destroyed by </para>
        // <para>  The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight</para>
        // <para>  bits per channel.  They are arranged canonically as packed sequential rows,</para>
        // <para>  starting from the top-left corner.</para>
        // <para>  The cursor hotspot is specified in pixels, relative to the upper-left corner</para>
        // <para>  of the cursor image.  Like all other coordinate systems in GLFW, the X-axis</para>
        // <para>  points to the right and the Y-axis points down.</para>
        // </remarks>
        // <param name="image">The desired cursor image.</param>
        // <param name="xhot">The desired x-coordinate, in pixels, of the cursor hotspot.</param>
        // <param name="yhot">The desired y-coordinate, in pixels, of the cursor hotspot.</param>
        // <returns>
        // <para>The handle of the created cursor, or `NULL` if an</para>
        // <para>[error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_lifetime The specified image data is copied before this function</para>
        // <para>returns.</para>
        // <para></para>
        // <para>This function must not be called from a callback.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWcursor GlfwCreateCursor(global::glfw3.GLFWimage image, int xhot, int yhot)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            var __ret = __Internal.GlfwCreateCursor_0(__arg0, xhot, yhot);
            global::glfw3.GLFWcursor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.GLFWcursor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.GLFWcursor) global::glfw3.GLFWcursor.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.GLFWcursor.__CreateInstance(__ret);
            return __result0;
        }

        // <remarks>
        // <para>  Returns a cursor with a [standard shape](</para>
        // <para>  a window with </para>
        // </remarks>
        // <param name="shape">One of the [standard shapes](</param>
        // <returns>
        // <para>A new cursor ready to use or `NULL` if an</para>
        // <para>[error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_INVALID_ENUM and</para>
        // <para></para>
        // <para>This function must not be called from a callback.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWcursor GlfwCreateStandardCursor(int shape)
        {
            var __ret = __Internal.GlfwCreateStandardCursor_0(shape);
            global::glfw3.GLFWcursor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.GLFWcursor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.GLFWcursor) global::glfw3.GLFWcursor.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.GLFWcursor.__CreateInstance(__ret);
            return __result0;
        }

        // <remarks>
        // <para>  This function destroys a cursor previously created with </para>
        // <para>  glfwCreateCursor.  Any remaining cursors will be destroyed by </para>
        // <para>  glfwTerminate.</para>
        // </remarks>
        // <param name="cursor">
        // <para>The cursor object to destroy.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>This function must not be called from a callback.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwDestroyCursor(global::glfw3.GLFWcursor cursor)
        {
            var __arg0 = ReferenceEquals(cursor, null) ? global::System.IntPtr.Zero : cursor.__Instance;
            __Internal.GlfwDestroyCursor_0(__arg0);
        }

        // <remarks>
        // <para>  This function sets the cursor image to be used when the cursor is over the</para>
        // <para>  client area of the specified window.  The set cursor will only be visible</para>
        // <para>  when the [cursor mode](</para>
        // <para>  `GLFW_CURSOR_NORMAL`.</para>
        // <para>  On some platforms, the set cursor may not be visible unless the window also</para>
        // <para>  has input focus.</para>
        // </remarks>
        // <param name="window">The window to set the cursor for.</param>
        // <param name="cursor">
        // <para>The cursor to set, or `NULL` to switch back to the default</para>
        // <para>arrow cursor.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwSetCursor(global::glfw3.GLFWwindow window, global::glfw3.GLFWcursor cursor)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = ReferenceEquals(cursor, null) ? global::System.IntPtr.Zero : cursor.__Instance;
            __Internal.GlfwSetCursor_0(__arg0, __arg1);
        }

        // <remarks>
        // <para>  This function sets the key callback of the specified window, which is called</para>
        // <para>  when a key is pressed, repeated or released.</para>
        // <para>  The key functions deal with physical keys, with layout independent</para>
        // <para>  [key tokens](</para>
        // <para>  layout.  If you want to input text, use the</para>
        // <para>  [character callback](</para>
        // <para>  When a window loses input focus, it will generate synthetic key release</para>
        // <para>  events for all pressed keys.  You can tell these events from user-generated</para>
        // <para>  events by the fact that the synthetic ones are generated after the focus</para>
        // <para>  loss event has been processed, i.e. after the</para>
        // <para>  [window focus callback](</para>
        // <para>  The scancode of a key is specific to that platform or sometimes even to that</para>
        // <para>  machine.  Scancodes are intended to allow users to bind keys that don't have</para>
        // <para>  a GLFW key token.  Such keys have `key` set to `GLFW_KEY_UNKNOWN`, their</para>
        // <para>  state is not saved and so it cannot be queried with </para>
        // <para>  Sometimes GLFW needs to generate synthetic key events, in which case the</para>
        // <para>  scancode may be zero.</para>
        // </remarks>
        // <param name="window">The window whose callback to set.</param>
        // <param name="cbfun">
        // <para>The new key callback, or `NULL` to remove the currently</para>
        // <para>set callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set or the</para>
        // <para>library had not been [initialized](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWkeyfun GlfwSetKeyCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWkeyfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetKeyCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWkeyfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWkeyfun));
        }

        // <remarks>
        // <para>  This function sets the character callback of the specified window, which is</para>
        // <para>  called when a Unicode character is input.</para>
        // <para>  The character callback is intended for Unicode text input.  As it deals with</para>
        // <para>  characters, it is keyboard layout dependent, whereas the</para>
        // <para>  [key callback](</para>
        // <para>  to physical keys, as a key may produce zero, one or more characters.  If you</para>
        // <para>  want to know whether a specific physical key was pressed or released, see</para>
        // <para>  the key callback instead.</para>
        // <para>  The character callback behaves as system text input normally does and will</para>
        // <para>  not be called if modifier keys are held down that would prevent normal text</para>
        // <para>  input on that platform, for example a Super (Command) key on OS X or Alt key</para>
        // <para>  on Windows.  There is a</para>
        // <para>  [character with modifiers callback](</para>
        // <para>  receives these events.</para>
        // </remarks>
        // <param name="window">The window whose callback to set.</param>
        // <param name="cbfun">
        // <para>The new callback, or `NULL` to remove the currently set</para>
        // <para>callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set or the</para>
        // <para>library had not been [initialized](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWcharfun GlfwSetCharCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWcharfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetCharCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWcharfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWcharfun));
        }

        // <remarks>
        // <para>  This function sets the character with modifiers callback of the specified</para>
        // <para>  window, which is called when a Unicode character is input regardless of what</para>
        // <para>  modifier keys are used.</para>
        // <para>  The character with modifiers callback is intended for implementing custom</para>
        // <para>  Unicode character input.  For regular Unicode text input, see the</para>
        // <para>  [character callback](</para>
        // <para>  callback, the character with modifiers callback deals with characters and is</para>
        // <para>  keyboard layout dependent.  Characters do not map 1:1 to physical keys, as</para>
        // <para>  a key may produce zero, one or more characters.  If you want to know whether</para>
        // <para>  a specific physical key was pressed or released, see the</para>
        // <para>  [key callback](</para>
        // </remarks>
        // <param name="window">The window whose callback to set.</param>
        // <param name="cbfun">
        // <para>The new callback, or `NULL` to remove the currently set</para>
        // <para>callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set or an</para>
        // <para>[error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWcharmodsfun GlfwSetCharModsCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWcharmodsfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetCharModsCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWcharmodsfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWcharmodsfun));
        }

        // <remarks>
        // <para>  This function sets the mouse button callback of the specified window, which</para>
        // <para>  is called when a mouse button is pressed or released.</para>
        // <para>  When a window loses input focus, it will generate synthetic mouse button</para>
        // <para>  release events for all pressed mouse buttons.  You can tell these events</para>
        // <para>  from user-generated events by the fact that the synthetic ones are generated</para>
        // <para>  after the focus loss event has been processed, i.e. after the</para>
        // <para>  [window focus callback](</para>
        // </remarks>
        // <param name="window">The window whose callback to set.</param>
        // <param name="cbfun">
        // <para>The new callback, or `NULL` to remove the currently set</para>
        // <para>callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set or the</para>
        // <para>library had not been [initialized](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWmousebuttonfun GlfwSetMouseButtonCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWmousebuttonfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetMouseButtonCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWmousebuttonfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWmousebuttonfun));
        }

        // <remarks>
        // <para>  This function sets the cursor position callback of the specified window,</para>
        // <para>  which is called when the cursor is moved.  The callback is provided with the</para>
        // <para>  position, in screen coordinates, relative to the upper-left corner of the</para>
        // <para>  client area of the window.</para>
        // </remarks>
        // <param name="window">The window whose callback to set.</param>
        // <param name="cbfun">
        // <para>The new callback, or `NULL` to remove the currently set</para>
        // <para>callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set or the</para>
        // <para>library had not been [initialized](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWcursorposfun GlfwSetCursorPosCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWcursorposfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetCursorPosCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWcursorposfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWcursorposfun));
        }

        // <remarks>
        // <para>  This function sets the cursor boundary crossing callback of the specified</para>
        // <para>  window, which is called when the cursor enters or leaves the client area of</para>
        // <para>  the window.</para>
        // </remarks>
        // <param name="window">The window whose callback to set.</param>
        // <param name="cbfun">
        // <para>The new callback, or `NULL` to remove the currently set</para>
        // <para>callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set or the</para>
        // <para>library had not been [initialized](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWcursorenterfun GlfwSetCursorEnterCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWcursorenterfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetCursorEnterCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWcursorenterfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWcursorenterfun));
        }

        // <remarks>
        // <para>  This function sets the scroll callback of the specified window, which is</para>
        // <para>  called when a scrolling device is used, such as a mouse wheel or scrolling</para>
        // <para>  area of a touchpad.</para>
        // <para>  The scroll callback receives all scrolling input, like that from a mouse</para>
        // <para>  wheel or a touchpad scrolling area.</para>
        // </remarks>
        // <param name="window">The window whose callback to set.</param>
        // <param name="cbfun">
        // <para>The new scroll callback, or `NULL` to remove the currently</para>
        // <para>set callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set or the</para>
        // <para>library had not been [initialized](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWscrollfun GlfwSetScrollCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWscrollfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetScrollCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWscrollfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWscrollfun));
        }

        // <remarks>
        // <para>  This function sets the file drop callback of the specified window, which is</para>
        // <para>  called when one or more dragged files are dropped on the window.</para>
        // <para>  Because the path array and its strings may have been generated specifically</para>
        // <para>  for that event, they are not guaranteed to be valid after the callback has</para>
        // <para>  returned.  If you wish to use them after the callback returns, you need to</para>
        // <para>  make a deep copy.</para>
        // </remarks>
        // <param name="window">The window whose callback to set.</param>
        // <param name="cbfun">
        // <para>The new file drop callback, or `NULL` to remove the</para>
        // <para>currently set callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set or the</para>
        // <para>library had not been [initialized](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWdropfun GlfwSetDropCallback(global::glfw3.GLFWwindow window, global::glfw3.GLFWdropfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetDropCallback_0(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWdropfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWdropfun));
        }

        // <remarks>  This function returns whether the specified joystick is present.</remarks>
        // <param name="joy">The [joystick](</param>
        // <returns>
        // <para>`GLFW_TRUE` if the joystick is present, or `GLFW_FALSE` otherwise.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_INVALID_ENUM and</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static int GlfwJoystickPresent(int joy)
        {
            var __ret = __Internal.GlfwJoystickPresent_0(joy);
            return __ret;
        }

        // <remarks>
        // <para>  This function returns the values of all axes of the specified joystick.</para>
        // <para>  Each element in the array is a value between -1.0 and 1.0.</para>
        // <para>  Querying a joystick slot with no device present is not an error, but will</para>
        // <para>  cause this function to return `NULL`.  Call </para>
        // <para>  check device presence.</para>
        // </remarks>
        // <param name="joy">The [joystick](</param>
        // <param name="count">
        // <para>Where to store the number of axis values in the returned</para>
        // <para>array.  This is set to zero if the joystick is not present or an error</para>
        // <para>occurred.</para>
        // </param>
        // <returns>
        // <para>An array of axis values, or `NULL` if the joystick is not present or</para>
        // <para>an [error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_INVALID_ENUM and</para>
        // <para></para>
        // <para>_lifetime The returned array is allocated and freed by GLFW.  You</para>
        // <para>should not free it yourself.  It is valid until the specified joystick is</para>
        // <para>disconnected, this function is called again for that joystick or the library</para>
        // <para>is terminated.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static float* GlfwGetJoystickAxes(int joy, ref int count)
        {
            fixed (int* __refParamPtr1 = &count)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.GlfwGetJoystickAxes_0(joy, __arg1);
                return __ret;
            }
        }

        // <remarks>
        // <para>  This function returns the state of all buttons of the specified joystick.</para>
        // <para>  Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`.</para>
        // <para>  Querying a joystick slot with no device present is not an error, but will</para>
        // <para>  cause this function to return `NULL`.  Call </para>
        // <para>  check device presence.</para>
        // </remarks>
        // <param name="joy">The [joystick](</param>
        // <param name="count">
        // <para>Where to store the number of button states in the returned</para>
        // <para>array.  This is set to zero if the joystick is not present or an error</para>
        // <para>occurred.</para>
        // </param>
        // <returns>
        // <para>An array of button states, or `NULL` if the joystick is not present</para>
        // <para>or an [error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_INVALID_ENUM and</para>
        // <para></para>
        // <para>_lifetime The returned array is allocated and freed by GLFW.  You</para>
        // <para>should not free it yourself.  It is valid until the specified joystick is</para>
        // <para>disconnected, this function is called again for that joystick or the library</para>
        // <para>is terminated.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static byte* GlfwGetJoystickButtons(int joy, ref int count)
        {
            fixed (int* __refParamPtr1 = &count)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.GlfwGetJoystickButtons_0(joy, __arg1);
                return __ret;
            }
        }

        // <remarks>
        // <para>  This function returns the name, encoded as UTF-8, of the specified joystick.</para>
        // <para>  The returned string is allocated and freed by GLFW.  You should not free it</para>
        // <para>  yourself.</para>
        // <para>  Querying a joystick slot with no device present is not an error, but will</para>
        // <para>  cause this function to return `NULL`.  Call </para>
        // <para>  check device presence.</para>
        // </remarks>
        // <param name="joy">The [joystick](</param>
        // <returns>
        // <para>The UTF-8 encoded name of the joystick, or `NULL` if the joystick</para>
        // <para>is not present or an [error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_INVALID_ENUM and</para>
        // <para></para>
        // <para>_lifetime The returned string is allocated and freed by GLFW.  You</para>
        // <para>should not free it yourself.  It is valid until the specified joystick is</para>
        // <para>disconnected, this function is called again for that joystick or the library</para>
        // <para>is terminated.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static string GlfwGetJoystickName(int joy)
        {
            var __ret = __Internal.GlfwGetJoystickName_0(joy);
            return Marshal.PtrToStringAnsi(__ret);
        }

        // <remarks>
        // <para>  This function sets the joystick configuration callback, or removes the</para>
        // <para>  currently set callback.  This is called when a joystick is connected to or</para>
        // <para>  disconnected from the system.</para>
        // </remarks>
        // <param name="cbfun">
        // <para>The new callback, or `NULL` to remove the currently set</para>
        // <para>callback.</para>
        // </param>
        // <returns>
        // <para>The previously set callback, or `NULL` if no callback was set or the</para>
        // <para>library had not been [initialized](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static global::glfw3.GLFWjoystickfun GlfwSetJoystickCallback(global::glfw3.GLFWjoystickfun cbfun)
        {
            var __arg0 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetJoystickCallback_0(__arg0);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWjoystickfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWjoystickfun));
        }

        // <remarks>
        // <para>  This function sets the system clipboard to the specified, UTF-8 encoded</para>
        // <para>  string.</para>
        // </remarks>
        // <param name="window">The window that will own the clipboard contents.</param>
        // <param name="string">
        // <para>A UTF-8 encoded string.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_lifetime The specified string is copied before this function</para>
        // <para>returns.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </param>
        public static void GlfwSetClipboardString(global::glfw3.GLFWwindow window, string @string)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetClipboardString_0(__arg0, @string);
        }

        // <remarks>
        // <para>  This function returns the contents of the system clipboard, if it contains</para>
        // <para>  or is convertible to a UTF-8 encoded string.  If the clipboard is empty or</para>
        // <para>  if its contents cannot be converted, `NULL` is returned and a </para>
        // <para>  GLFW_FORMAT_UNAVAILABLE error is generated.</para>
        // </remarks>
        // <param name="window">The window that will request the clipboard contents.</param>
        // <returns>
        // <para>The contents of the clipboard as a UTF-8 encoded string, or `NULL`</para>
        // <para>if an [error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_lifetime The returned string is allocated and freed by GLFW.  You</para>
        // <para>should not free it yourself.  It is valid until the next call to</para>
        // <para>glfwGetClipboardString or</para>
        // <para>is terminated.</para>
        // <para></para>
        // <para>_safety This function must only be called from the main thread.</para>
        // </returns>
        public static string GlfwGetClipboardString(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetClipboardString_0(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        // <remarks>
        // <para>  This function returns the value of the GLFW timer.  Unless the timer has</para>
        // <para>  been set using </para>
        // <para>  was initialized.</para>
        // <para>  The resolution of the timer is system dependent, but is usually on the order</para>
        // <para>  of a few micro- or nanoseconds.  It uses the highest-resolution monotonic</para>
        // <para>  time source on each supported platform.</para>
        // </remarks>
        // <returns>
        // <para>The current value, in seconds, or zero if an</para>
        // <para>[error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function may be called from any thread.  Reading and</para>
        // <para>writing of the internal timer offset is not atomic, so it needs to be</para>
        // <para>externally synchronized with calls to</para>
        // </returns>
        public static double GlfwGetTime()
        {
            var __ret = __Internal.GlfwGetTime_0();
            return __ret;
        }

        // <remarks>
        // <para>  This function sets the value of the GLFW timer.  It then continues to count</para>
        // <para>  up from that value.  The value must be a positive finite number less than</para>
        // <para>  or equal to 18446744073.0, which is approximately 584.5 years.</para>
        // </remarks>
        // <param name="time">
        // <para>The new value, in seconds.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_INVALID_VALUE.</para>
        // <para></para>
        // <para></para>
        // <para>_safety This function may be called from any thread.  Reading and</para>
        // <para>writing of the internal timer offset is not atomic, so it needs to be</para>
        // <para>externally synchronized with calls to</para>
        // </param>
        public static void GlfwSetTime(double time)
        {
            __Internal.GlfwSetTime_0(time);
        }

        // <remarks>
        // <para>  This function returns the current value of the raw timer, measured in</para>
        // <para>  1</para>
        // <para>&#160;</para>
        // <para>/</para>
        // <para>&#160;</para>
        // <para>frequency seconds.  To get the frequency, call </para>
        // <para>  glfwGetTimerFrequency.</para>
        // </remarks>
        // <returns>
        // <para>The value of the timer, or zero if an</para>
        // <para>[error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function may be called from any thread.</para>
        // </returns>
        public static ulong GlfwGetTimerValue()
        {
            var __ret = __Internal.GlfwGetTimerValue_0();
            return __ret;
        }

        // <remarks>  This function returns the frequency, in Hz, of the raw timer.</remarks>
        // <returns>
        // <para>The frequency of the timer, in Hz, or zero if an</para>
        // <para>[error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function may be called from any thread.</para>
        // </returns>
        public static ulong GlfwGetTimerFrequency()
        {
            var __ret = __Internal.GlfwGetTimerFrequency_0();
            return __ret;
        }

        // <remarks>
        // <para>  This function makes the OpenGL or OpenGL ES context of the specified window</para>
        // <para>  current on the calling thread.  A context can only be made current on</para>
        // <para>  a single thread at a time and each thread can have only a single current</para>
        // <para>  context at a time.</para>
        // <para>  By default, making a context non-current implicitly forces a pipeline flush.</para>
        // <para>  On machines that support `GL_KHR_context_flush_control`, you can control</para>
        // <para>  whether a context performs this flush by setting the</para>
        // <para>  [GLFW_CONTEXT_RELEASE_BEHAVIOR](</para>
        // <para>  The specified window must have an OpenGL or OpenGL ES context.  Specifying</para>
        // <para>  a window without a context will generate a </para>
        // <para>  error.</para>
        // </remarks>
        // <param name="window">
        // <para>The window whose context to make current, or `NULL` to</para>
        // <para>detach the current context.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_NO_WINDOW_CONTEXT and</para>
        // <para></para>
        // <para>_safety This function may be called from any thread.</para>
        // </param>
        public static void GlfwMakeContextCurrent(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwMakeContextCurrent_0(__arg0);
        }

        // <remarks>
        // <para>  This function returns the window whose OpenGL or OpenGL ES context is</para>
        // <para>  current on the calling thread.</para>
        // </remarks>
        // <returns>
        // <para>The window whose context is current, or `NULL` if no window's</para>
        // <para>context is current.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function may be called from any thread.</para>
        // </returns>
        public static global::glfw3.GLFWwindow GlfwGetCurrentContext()
        {
            var __ret = __Internal.GlfwGetCurrentContext_0();
            global::glfw3.GLFWwindow __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::glfw3.GLFWwindow.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::glfw3.GLFWwindow) global::glfw3.GLFWwindow.NativeToManagedMap[__ret];
            else __result0 = global::glfw3.GLFWwindow.__CreateInstance(__ret);
            return __result0;
        }

        // <remarks>
        // <para>  This function swaps the front and back buffers of the specified window when</para>
        // <para>  rendering with OpenGL or OpenGL ES.  If the swap interval is greater than</para>
        // <para>  zero, the GPU driver waits the specified number of screen updates before</para>
        // <para>  swapping the buffers.</para>
        // <para>  The specified window must have an OpenGL or OpenGL ES context.  Specifying</para>
        // <para>  a window without a context will generate a </para>
        // <para>  error.</para>
        // <para>  This function does not apply to Vulkan.  If you are rendering with Vulkan,</para>
        // <para>  see `vkQueuePresentKHR` instead.</para>
        // </remarks>
        // <param name="window">
        // <para>The window whose buffers to swap.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_NO_WINDOW_CONTEXT and</para>
        // <para></para>
        // <para></para>
        // <para>_safety This function may be called from any thread.</para>
        // </param>
        public static void GlfwSwapBuffers(global::glfw3.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSwapBuffers_0(__arg0);
        }

        // <remarks>
        // <para>  This function sets the swap interval for the current OpenGL or OpenGL ES</para>
        // <para>  context, i.e. the number of screen updates to wait from the time </para>
        // <para>  glfwSwapBuffers was called before swapping the buffers and returning.  This</para>
        // <para>  is sometimes called _vertical synchronization_, _vertical retrace</para>
        // <para>  synchronization_ or just _vsync_.</para>
        // <para>  Contexts that support either of the `WGL_EXT_swap_control_tear` and</para>
        // <para>  `GLX_EXT_swap_control_tear` extensions also accept negative swap intervals,</para>
        // <para>  which allow the driver to swap even if a frame arrives a little bit late.</para>
        // <para>  You can check for the presence of these extensions using </para>
        // <para>  glfwExtensionSupported.  For more information about swap tearing, see the</para>
        // <para>  extension specifications.</para>
        // <para>  A context must be current on the calling thread.  Calling this function</para>
        // <para>  without a current context will cause a </para>
        // <para>  This function does not apply to Vulkan.  If you are rendering with Vulkan,</para>
        // <para>  see the present mode of your swapchain instead.</para>
        // </remarks>
        // <param name="interval">
        // <para>The minimum number of screen updates to wait for</para>
        // <para>until the buffers are swapped by</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_NO_CURRENT_CONTEXT and</para>
        // <para></para>
        // <para></para>
        // <para></para>
        // <para>_safety This function may be called from any thread.</para>
        // </param>
        public static void GlfwSwapInterval(int interval)
        {
            __Internal.GlfwSwapInterval_0(interval);
        }

        // <remarks>
        // <para>  This function returns whether the specified</para>
        // <para>  [API extension](</para>
        // <para>  OpenGL ES context.  It searches both for client API extension and context</para>
        // <para>  creation API extensions.</para>
        // <para>  A context must be current on the calling thread.  Calling this function</para>
        // <para>  without a current context will cause a </para>
        // <para>  As this functions retrieves and searches one or more extension strings each</para>
        // <para>  call, it is recommended that you cache its results if it is going to be used</para>
        // <para>  frequently.  The extension strings will not change during the lifetime of</para>
        // <para>  a context, so there is no danger in doing this.</para>
        // <para>  This function does not apply to Vulkan.  If you are using Vulkan, see </para>
        // <para>  glfwGetRequiredInstanceExtensions, `vkEnumerateInstanceExtensionProperties`</para>
        // <para>  and `vkEnumerateDeviceExtensionProperties` instead.</para>
        // </remarks>
        // <param name="extension">The ASCII encoded name of the extension.</param>
        // <returns>
        // <para>`GLFW_TRUE` if the extension is available, or `GLFW_FALSE`</para>
        // <para>otherwise.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_NO_CURRENT_CONTEXT,</para>
        // <para>GLFW_PLATFORM_ERROR.</para>
        // <para></para>
        // <para>_safety This function may be called from any thread.</para>
        // </returns>
        public static int GlfwExtensionSupported(string extension)
        {
            var __ret = __Internal.GlfwExtensionSupported_0(extension);
            return __ret;
        }

        // <remarks>
        // <para>  This function returns the address of the specified OpenGL or OpenGL ES</para>
        // <para>  [core or extension function](</para>
        // <para>  by the current context.</para>
        // <para>  A context must be current on the calling thread.  Calling this function</para>
        // <para>  without a current context will cause a </para>
        // <para>  This function does not apply to Vulkan.  If you are rendering with Vulkan,</para>
        // <para>  see </para>
        // <para>  `vkGetDeviceProcAddr` instead.</para>
        // </remarks>
        // <param name="procname">The ASCII encoded name of the function.</param>
        // <returns>
        // <para>The address of the function, or `NULL` if an</para>
        // <para>[error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_NO_CURRENT_CONTEXT and</para>
        // <para></para>
        // <para></para>
        // <para></para>
        // <para>_lifetime The returned function pointer is valid until the context</para>
        // <para>is destroyed or the library is terminated.</para>
        // <para></para>
        // <para>_safety This function may be called from any thread.</para>
        // </returns>
        public static global::glfw3.GLFWglproc GlfwGetProcAddress(string procname)
        {
            var __ret = __Internal.GlfwGetProcAddress_0(procname);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::glfw3.GLFWglproc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::glfw3.GLFWglproc));
        }

        // <remarks>
        // <para>  This function returns whether the Vulkan loader has been found.  This check</para>
        // <para>  is performed by </para>
        // <para>  The availability of a Vulkan loader does not by itself guarantee that window</para>
        // <para>  surface creation or even device creation is possible.  Call </para>
        // <para>  glfwGetRequiredInstanceExtensions to check whether the extensions necessary</para>
        // <para>  for Vulkan surface creation are available and </para>
        // <para>  glfwGetPhysicalDevicePresentationSupport to check whether a queue family of</para>
        // <para>  a physical device supports image presentation.</para>
        // </remarks>
        // <returns>
        // <para>`GLFW_TRUE` if Vulkan is available, or `GLFW_FALSE` otherwise.</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para></para>
        // <para>_safety This function may be called from any thread.</para>
        // </returns>
        public static int GlfwVulkanSupported()
        {
            var __ret = __Internal.GlfwVulkanSupported_0();
            return __ret;
        }

        // <remarks>
        // <para>  This function returns an array of names of Vulkan instance extensions required</para>
        // <para>  by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the</para>
        // <para>  list will always contains `VK_KHR_surface`, so if you don't require any</para>
        // <para>  additional extensions you can pass this list directly to the</para>
        // <para>  `VkInstanceCreateInfo` struct.</para>
        // <para>  If Vulkan is not available on the machine, this function returns `NULL` and</para>
        // <para>  generates a </para>
        // <para>  to check whether Vulkan is available.</para>
        // <para>  If Vulkan is available but no set of extensions allowing window surface</para>
        // <para>  creation was found, this function returns `NULL`.  You may still use Vulkan</para>
        // <para>  for off-screen rendering and compute work.</para>
        // </remarks>
        // <param name="count">
        // <para>Where to store the number of extensions in the returned</para>
        // <para>array.  This is set to zero if an error occurred.</para>
        // </param>
        // <returns>
        // <para>An array of ASCII encoded extension names, or `NULL` if an</para>
        // <para>[error](</para>
        // <para></para>
        // <para>Possible errors include</para>
        // <para>GLFW_API_UNAVAILABLE.</para>
        // <para></para>
        // <para></para>
        // <para>_lifetime The returned array is allocated and freed by GLFW.  You</para>
        // <para>should not free it yourself.  It is guaranteed to be valid only until the</para>
        // <para>library is terminated.</para>
        // <para></para>
        // <para>_safety This function may be called from any thread.</para>
        // </returns>
        public static sbyte** GlfwGetRequiredInstanceExtensions(ref uint count)
        {
            fixed (uint* __refParamPtr0 = &count)
            {
                var __arg0 = __refParamPtr0;
                var __ret = __Internal.GlfwGetRequiredInstanceExtensions_0(__arg0);
                return __ret;
            }
        }
    }
}
